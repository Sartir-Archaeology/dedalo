/*global get_label, page_globals, SHOW_DEBUG, DEDALO_LIB_URL*/
/*eslint no-undef: "error"*/



// imports
	// import {event_manager} from '../../common/js/event_manager.js'
	import {ui} from '../../common/js/ui.js'
	import {open_tool} from '../../../tools/tool_common/js/tool_common.js'
	import {when_in_viewport} from '../../common/js/events.js'

	// used a importmap define in page/index.html to resolve directories
	// the main addons is /lib/threejs/jsm/ has to be mapped as three/
	// (!) Safari compatibility ??? : https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap#browser_compatibility
	import * as THREE from 'three'
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js'
	import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
	// import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader.js';
	// import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';
	import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';



/**
* VIEW_DEFAULT_EDIT_3D
* Manages the component's logic and appearance in client side
*/
export const view_default_edit_3d = function() {

	return true
}//end  view_default_edit_3d



/**
* RENDER
* Render node for use in modes: edit, edit_in_list
* @return HTMLElement wrapper
*/
view_default_edit_3d.render = async function(self, options) {

	// options
		const render_level = options.render_level || 'full'

	// content_data
		const content_data = await get_content_data_edit(self)
		// console.log(content_data)
		if (render_level==='content') {
			return content_data
		}

	/// buttons
		const buttons = (self.permissions > 1)
			? get_buttons(self)
			: null

	// wrapper. ui build_edit returns component wrapper
		const wrapper = ui.component.build_wrapper_edit(self, {
			content_data : content_data,
			buttons 	 : buttons
		})
		// set pointers to content_data
		wrapper.content_data = content_data

	return wrapper
}//end view_default_edit_3d



/**
* GET_CONTENT_DATA_EDIT
* This renders the data
* @param self the component_3d instance
* @return HTMLElement content_data
*/
const get_content_data_edit = function(self) {

	// Load threeJS library
	// await self.load_editor_files()

	// short vars
		const data	= self.data || {}  // content generated by the server related to the envolving data structure
		const value	= data.value || []  // content generated by the server related to the file itself

	// content_data
		const content_data = ui.component.build_content_data(self)

	// values (inputs)
		const inputs_value	= (value.length>0) ? value : [null] // force one empty input at least
		const value_length	= inputs_value.length
		for (let i = 0; i < value_length; i++) {
			const content_value = (self.permissions===1)
				? get_content_value_read(i, inputs_value[i], self)
				: get_content_value(i, inputs_value[i], self)
			content_data.appendChild(content_value)
			// set pointer
			content_data[i] = content_value
		}

	console.log(content_data)


	return content_data
}//end  get_content_data_edit



/**
* GET_CONTENT_VALUE
* @return HTMLElement content_value
*/
const get_content_value = (i, current_value, self) => {

	// content_value
		/** @type {HTMLDivElement} */
		const content_value = ui.create_dom_element({
			element_type	: 'div',
			class_name 		: 'content_value'
		})

		const canvas = ui.create_dom_element({
			element_type	: 'canvas',
			// class_name 		: 'content_value',
			parent 			: content_value
		})

	// get file quality
		const quality	= self.quality || self.context.features.quality
		const datalist	= self.data.datalist
		const file_info	= datalist.find(el => el.quality===quality && el.file_exist===true)
		const file_url	= file_info
			? file_info.file_url
			: null

		if(!file_url){
			return content_value
		}

		const renderer = new THREE.WebGLRenderer({canvas:canvas, antialias:true});
		renderer.outputEncoding = THREE.sRGBEncoding;

		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( 1000, 600 );

		// Instantiate camera
		const fov		= 45;
		const aspect	= 2;  // the canvas default
		const near		= 0.1;
		const far		= 100;
		const camera = new THREE.PerspectiveCamera( fov, aspect, near, far)
		camera.position.set(0, 10, 20);
		// self.camera = camera


		const controls = new OrbitControls(camera, canvas);
		controls.target.set(0, 5, 0);
		controls.update();

		// Instantiate scene
		const scene = new THREE.Scene()
		// self.scene = scene

		// {
		// 	const planeSize = 40;

		// 	const loader = new THREE.TextureLoader();
		// 	const texture = loader.load('https://threejs.org/manual/examples/resources/images/checker.png');
		// 	texture.wrapS = THREE.RepeatWrapping;
		// 	texture.wrapT = THREE.RepeatWrapping;
		// 	texture.magFilter = THREE.NearestFilter;
		// 	const repeats = planeSize / 2;
		// 	texture.repeat.set(repeats, repeats);

		// 	const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
		// 	const planeMat = new THREE.MeshPhongMaterial({
		// 	map: texture,
		// 	side: THREE.DoubleSide,
		// 	});
		// 	const mesh = new THREE.Mesh(planeGeo, planeMat);
		// 	mesh.rotation.x = Math.PI * -.5;
		// 	scene.add(mesh);
		// }

		// add hemisphere light
		{
			const skyColor = 0xB1E1FF;  // light blue
			const groundColor = 0xB97A20;  // brownish orange
			const intensity = 0.6;
			const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
			scene.add(light);
		}
		// add directional light
		{
			const color = 0xFFFFFF;
			const intensity = 0.8;
			const light = new THREE.DirectionalLight(color, intensity);
			light.position.set(5, 10, 2);
			scene.add(light);
			scene.add(light.target);
		}


		// scene.add( camera );


		// content_value.appendChild(renderer.domElement)
		// self.renderer = renderer


		// const geometry = new THREE.BoxGeometry( 1, 1, 1 );
		// const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
		// const cube = new THREE.Mesh( geometry, material );
		// scene.add( cube );

		camera.position.z = 5;

		function render() {
			// requestAnimationFrame( animate );
			renderer.render( scene,  camera );
		}

		const MANAGER = new THREE.LoadingManager();

		// Instantiate a GLTF + DRACO loader
		const loader = new GLTFLoader( MANAGER )
		const dracoLoader = new DRACOLoader(MANAGER);
		dracoLoader.setDecoderPath( '../../lib/threejs/jsm/libs/draco/' );  // path is weird
		loader.setDRACOLoader( dracoLoader );

		// Instantiate a GLTF + KTX2Loader loader
		const ktx2_loader = new KTX2Loader( MANAGER )
		ktx2_loader.setTranscoderPath( '../../lib/threejs/jsm/libs/basis/' );
		loader.setKTX2Loader( ktx2_loader.detectSupport( renderer ) )

		// Insatntiate a GLTF + MeshoptDecoder
		loader.setMeshoptDecoder( MeshoptDecoder );
		loader.load(
			// resource URL   # TODO: change find with quality selector
				file_url,
			// called when the resource is loaded
			function ( gltf ) {

				const object = gltf.scene
				scene.add( object );
				// gltf.animations; // Array<THREE.AnimationClip>
				// gltf.scene; // THREE.Group
				// gltf.scenes; // Array<THREE.Group>
				// gltf.cameras; // Array<THREE.Camera>
				// gltf.asset; // Object


				// compute the box that contains all the stuff
				// from root and below
				const box = new THREE.Box3().setFromObject(object);

				const boxSize	= box.getSize(new THREE.Vector3()).length();
				const boxCenter	= box.getCenter(new THREE.Vector3());

				// set the camera to frame the box
				frameArea(boxSize * 0.5, boxSize, boxCenter, camera);

				// update the Trackball controls to handle the new size
					controls.maxDistance = boxSize * 10;
					controls.target.copy(boxCenter);
					controls.update();
				// renderer.render(scene, camera)
				console.log('FINISHED LOADING!')

				 console.log(dumpObject(object).join('\n'));

				// renderer.render( scene, camera );
				render();
			},
			// called while loading is progressing
			function ( xhr ) {
				console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' )
			},
			// called when loading has errors
			function ( error ) {
				console.log( 'An error happened', error )
			}
		)


		function resizeRendererToDisplaySize(renderer) {
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
				renderer.setSize(width, height, false);
			}
				return needResize;
		}

		// Instantiate renderer
			function render() {
				if (resizeRendererToDisplaySize(renderer)) {
					const canvas = renderer.domElement;
					camera.aspect = canvas.clientWidth / canvas.clientHeight;
					camera.updateProjectionMatrix();
				}

				renderer.render(scene, camera);

				requestAnimationFrame(render);
			}

		// get ad set frameArea
		 function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
			const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
			const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
			const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
			// compute a unit vector that points in the direction the camera is now
			// in the xz plane from the center of the box
			const direction = (new THREE.Vector3())
				.subVectors(camera.position, boxCenter)
				.multiply(new THREE.Vector3(1, 0, 1))
				.normalize();

			// move the camera to a position distance units way from the center
			// in whatever direction the camera was from the center already
			camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

			// pick some near and far values for the frustum that
			// will contain the box.
			camera.near = boxSize / 100;
			camera.far = boxSize * 100;

			camera.updateProjectionMatrix();

			// point the camera to look at the center of the box
			camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
		  }


	// // urls
	// 	// posterframe url
	// 		const posterframe_url = self.data.posterframe_url
	// 	// media url from data.datalist based on selected context quality
	// 		const quality	= self.quality || self.context.features.quality
	// 		const datalist	= self.data.datalist
	// 		const file_info	= datalist.find(el => el.quality===quality && el.file_exist===true)
	// 		const video_url	= file_info
	// 			? file_info.file_url
	// 			: null

	// 	// background content_value. Load the posterframe image only to get the bg color, not for show it
	// 		// if (posterframe_url) {
	// 		// 	const image = ui.create_dom_element({
	// 		// 		element_type: 'img'
	// 		// 	})
	// 		// 	// image background color
	// 		// 	image.addEventListener('load', set_bg_color, false)
	// 		// 	function set_bg_color() {
	// 		// 		this.removeEventListener('load', set_bg_color, false)
	// 		// 		ui.set_background_image(this, content_value)
	// 		// 		image.remove()
	// 		// 	}
	// 		// 	image.src = posterframe_url
	// 		// }

	// 	// posterframe image
	// 		const posterframe = ui.create_dom_element({
	// 			element_type	: 'img',
	// 			class_name		: 'posterframe',
	// 			src				: posterframe_url,
	// 			parent			: content_value
	// 		})

	// // video / posterframe cases
	// 	if (video_url) {

	// 		const video = build_3d_node(
	// 			posterframe_url
	// 		)
	// 		// fix pointer
	// 		content_value.video = video
	// 		// append node to content_value
	// 		content_value.prepend(video)

	// 		// fix pointer to allow play/pause
	// 		self.video = video

	// 		// observer. Set video node only when it is in viewport (to save browser resources)
	// 		when_in_viewport(
	// 			content_value, // node to observe
	// 			() => { // callback function returns int timestamp
	// 				posterframe.remove()
	// 				video.src		= video_url
	// 				video.classList.remove('hide')
	// 			}
	// 		)
	// 	}else{

	// 		posterframe.classList.add('link')
	// 		posterframe.addEventListener('mouseup', function(e) {
	// 			e.stopPropagation();

	// 			const tool_upload = self.tools.find(el => el.model==='tool_upload')
	// 			// open_tool (tool_common)
	// 				open_tool({
	// 					tool_context	: tool_upload,
	// 					caller			: self
	// 				})
	// 		})
	// 	}

	// // quality_selector
	// 	const quality_selector = get_quality_selector(content_value, self)
	// 	content_value.appendChild(quality_selector)


	return content_value
}//end get_content_value



/**
* GET_CONTENT_VALUE_READ
* @param int i
* @param string current_value
* @param object self
* @return HTMLElement content_value
*/
const get_content_value_read = (i, current_value, self) => {

	// content_value
		const content_value = ui.create_dom_element({
			element_type	: 'div',
			class_name		: 'content_value read_only',
			inner_html		: 'Working in this view ' + self.view
		})


	return content_value
}//end get_content_value_read



// show mesh strucure
function dumpObject(obj, lines = [], isLast = true, prefix = '') {
	const localPrefix = isLast ? '└─' : '├─';
	lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
	const newPrefix = prefix + (isLast ? '  ' : '│ ');
	const lastNdx = obj.children.length - 1;
	obj.children.forEach((child, ndx) => {
		const isLast = ndx === lastNdx;
		dumpObject(child, lines, isLast, newPrefix);
	});
	return lines;
}



/**
* BUILD_3D_NODE
*
* @param string|null posterframe_url
* @return HTMLElement video
*/
const build_3d_node = (posterframe_url) => {

	// source tag
		const source	= document.createElement('source')
		source.type		= 'video/mp4'
		// source.src	= video_url

	// video tag
		const video		= document.createElement('video')
		video.classList.add('hide')
		if (posterframe_url) {
			video.poster = posterframe_url
		}
		video.controls	= true
		video.classList.add('posterframe')
		video.setAttribute('tabindex', 0)
		video.appendChild(source)

	// keyup event
		// video.addEventListener("timeupdate", async (e) => {
		// 	// e.stopPropagation()
		// 	// const frame = Math.floor(video.currentTime.toFixed(5) * 25);
		// })

	// canplay event
		// video.addEventListener('canplay', fn_canplay)
		// function fn_canplay() {
		// 	// self.main_component.video.removeEventListener('canplay', fn_play);
		// 	video.play()
		// }

	return video
}//end build_3D_node



/**
* GET_QUALITY_SELECTOR
*
* @param object content_value
* @return HTMLElement select
*/
const get_quality_selector = (content_value, self) => {

	// short vars
		const data		= self.data
		const quality	= self.quality || self.context.features.quality
		const video		= content_value.video

		const fragment = new DocumentFragment()

	// create the quality selector
		const quality_selector = ui.create_dom_element({
			element_type	: 'select',
			class_name		: 'quality_selector',
			parent			: fragment
		})
		quality_selector.addEventListener('change', (e) =>{
			const src = e.target.value
			// self.video.src = src
			video.src = src
			// event_manager.publish('image_quality_change_'+self.id, img_src)
			console.log("src:",src);
		})

		const quality_list		= data.datalist.filter(el => el.file_exist===true)
		const quality_list_len	= quality_list.length
		for (let i = 0; i < quality_list_len; i++) {
			// create the node with the all qualities sent by server
			const value = (typeof quality_list[i].file_url==='undefined')
				? '' // DEDALO_CORE_URL + "/themes/default/0.jpg"
				: quality_list[i].file_url

			const select_option = ui.create_dom_element({
				element_type	: 'option',
				value			: value,
				text_node		: quality_list[i].quality,
				parent			: quality_selector
			})
			//set the default quality_list to config variable dedalo_image_quality_default
			select_option.selected = quality_list[i].quality===quality ? true : false
		}


	return quality_selector
}//end get_quality_selector



/**
* GET_BUTTONS
* @param object instance
* @return HTMLElement buttons_container
*/
const get_buttons = (self) => {

	const fragment = new DocumentFragment()

	// prevent show buttons inside a tool
		if (self.caller && self.caller.type==='tool') {
			return fragment
		}

	// button_fullscreen
		const button_fullscreen = ui.create_dom_element({
			element_type	: 'span',
			class_name		: 'button full_screen',
			parent			: fragment
		})
		// button_fullscreen.addEventListener("mouseup", () =>{
		// 	self.node.classList.toggle('fullscreen')
		// 	const fullscreen_state = self.node.classList.contains('fullscreen') ? true : false
		// 	event_manager.publish('full_screen_'+self.id, fullscreen_state)
		// })
		button_fullscreen.addEventListener('click', function() {
			ui.enter_fullscreen(self.node)
		})


	// buttons tools
		ui.add_tools(self, fragment)

	// des
		// const button_info = ui.create_dom_element({
		// 	element_type	: 'span',
		// 	class_name 		: 'button full_screen',
		// 	parent 			: fragment
		// })
		// button_info.addEventListener("mouseup", async (e) =>{

		// 	const player_3d = await instances.get_instance({
		// 		model 			: 'component_3d',
		// 		section_tipo	: self.section_tipo,
		// 		section_id		: self.section_id,
		// 		tipo			: self.tipo,
		// 		context			: {},
		// 		mode 			: 'player'
		// 	})

		// 	await player_3d.build(true)

		// 	player_3d.fragment = {tc_in: 3, tc_out: 5}

		// 	const node = await player_3d.render()

		// 	// container, for every ipo will create a li node
		// 		const container = ui.create_dom_element({
		// 			element_type	: 'div'
		// 		})

		// 		self.node[0].appendChild(node)
		// })

	// buttons container
		const buttons_container = ui.component.build_buttons_container(self)
			// buttons_container.appendChild(fragment)

	// buttons_fold (allow sticky position on large components)
		const buttons_fold = ui.create_dom_element({
			element_type	: 'div',
			class_name		: 'buttons_fold',
			parent			: buttons_container
		})
		buttons_fold.appendChild(fragment)


	return buttons_container
}//end get_buttons
