/*global get_label, page_globals, SHOW_DEBUG, DEDALO_LIB_URL*/
/*eslint no-undef: "error"*/



// imports
	// import {event_manager} from '../../common/js/event_manager.js'
	import {ui} from '../../common/js/ui.js'
	import {open_tool} from '../../../tools/tool_common/js/tool_common.js'
	import {when_in_viewport} from '../../common/js/events.js'

	import * as THREE from 'three'
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
	import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js'



/**
* VIEW_DEFAULT_EDIT_3D
* Manages the component's logic and appearance in client side
*/
export const view_default_edit_3d = function() {

	return true
}//end  view_default_edit_3d



/**
* RENDER
* Render node for use in modes: edit, edit_in_list
* @return DOM node wrapper
*/
view_default_edit_3d.render = async function(self, options) {

	// options
		const render_level = options.render_level || 'full'

	// content_data
		const content_data = await get_content_data_edit(self)
		// console.log(content_data)
		if (render_level==='content') {
			return content_data
		}

	// buttons
		const buttons = get_buttons(self)

	// wrapper. ui build_edit returns component wrapper
		const wrapper = ui.component.build_wrapper_edit(self, {
			content_data : content_data,
			buttons 	 : buttons
		})
		// set pointers to content_data
		wrapper.content_data = content_data

	setTimeout(
		() => {
			console.log('RENDERING!')
			self.renderer.render(self.scene, self.camera)
		},
		3000
	)

	return wrapper
}//end view_default_edit_3d



/**
* GET_CONTENT_DATA_EDIT
* This renders the data
* @param self the component_3d instance
* @return DOM node content_data
*/
const get_content_data_edit = function(self) {

	// Load threeJS library
	// await self.load_editor_files()

	// short vars
		const data	= self.data || {}  // content generated by the server related to the envolving data structure
		const value	= data.value || []  // content generated by the server related to the file itself

		console.log(data)

	// content_data
		const content_data = ui.component.build_content_data(self)

	// values (inputs)
		const inputs_value	= (value.length>0) ? value : [null] // force one empty input at least
		const value_length	= inputs_value.length
		for (let i = 0; i < value_length; i++) {
			const content_value = get_content_value(i, inputs_value[i], self)
			content_data.appendChild(content_value)
			// set pointer
			content_data[i] = content_value
		}
	
	console.log(content_data)


	return content_data
}//end  get_content_data_edit



/**
* GET_CONTENT_VALUE
* @return DOM node content_value
*/
const get_content_value = (i, current_value, self) => {

	// content_value
		/** @type {HTMLDivElement} */
		const content_value = ui.create_dom_element({
			element_type	: 'div',
			class_name 		: 'content_value'
		})

		// Instantiate camera
		const camera = new THREE.PerspectiveCamera( 75, 1000 / 600, 0.1, 1000 )
		// camera.position.set( - 1.8, 0.6, 2.7 );
		self.camera = camera
		
		// Instantiate scene
		const scene = new THREE.Scene()
		self.scene = scene
		
		// Instantiate renderer
		const renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( 1000, 600 );
		content_value.appendChild(renderer.domElement)
		self.renderer = renderer

		// Instantiate a GLTF + DRACO loader
		const loader = new GLTFLoader()
		const dracoLoader = new DRACOLoader();
		dracoLoader.setDecoderPath( '../../lib/threejs/jsm/libs/draco/' );  // path is weird
		loader.setDRACOLoader( dracoLoader );
		loader.load(
			// resource URL   # TODO: change find with quality selector
			current_value.files_info.find((file_info) => file_info.quality == 'original').file_url,
			// called when the resource is loaded
			function ( gltf ) {

				scene.add( gltf.scene );

				// gltf.animations; // Array<THREE.AnimationClip>
				// gltf.scene; // THREE.Group
				// gltf.scenes; // Array<THREE.Group>
				// gltf.cameras; // Array<THREE.Camera>
				// gltf.asset; // Object

				// renderer.render(scene, camera)
				console.log('FINISHED LOADING!')

			},
			// called while loading is progressing
			function ( xhr ) {
				console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' )
			},
			// called when loading has errors
			function ( error ) {
				console.log( 'An error happened', error )
			}
		)


	// // urls
	// 	// posterframe url
	// 		const posterframe_url = self.data.posterframe_url
	// 	// media url from data.datalist based on selected context quality
	// 		const quality	= self.quality || self.context.features.quality
	// 		const datalist	= self.data.datalist
	// 		const file_info	= datalist.find(el => el.quality===quality && el.file_exist===true)
	// 		const video_url	= file_info
	// 			? file_info.file_url
	// 			: null

	// 	// background content_value. Load the posterframe image only to get the bg color, not for show it
	// 		// if (posterframe_url) {
	// 		// 	const image = ui.create_dom_element({
	// 		// 		element_type: 'img'
	// 		// 	})
	// 		// 	// image background color
	// 		// 	image.addEventListener('load', set_bg_color, false)
	// 		// 	function set_bg_color() {
	// 		// 		this.removeEventListener('load', set_bg_color, false)
	// 		// 		ui.set_background_image(this, content_value)
	// 		// 		image.remove()
	// 		// 	}
	// 		// 	image.src = posterframe_url
	// 		// }

	// 	// posterframe image
	// 		const posterframe = ui.create_dom_element({
	// 			element_type	: 'img',
	// 			class_name		: 'posterframe',
	// 			src				: posterframe_url,
	// 			parent			: content_value
	// 		})

	// // video / posterframe cases
	// 	if (video_url) {

	// 		const video = build_3d_node(
	// 			posterframe_url
	// 		)
	// 		// fix pointer
	// 		content_value.video = video
	// 		// append node to content_value
	// 		content_value.prepend(video)

	// 		// fix pointer to allow play/pause
	// 		self.video = video

	// 		// observer. Set video node only when it is in viewport (to save browser resources)
	// 		when_in_viewport(
	// 			content_value, // node to observe
	// 			() => { // callback function returns int timestamp
	// 				posterframe.remove()
	// 				video.src		= video_url
	// 				video.classList.remove('hide')
	// 			}
	// 		)
	// 	}else{

	// 		posterframe.classList.add('link')
	// 		posterframe.addEventListener('mouseup', function(e) {
	// 			e.stopPropagation();

	// 			const tool_upload = self.tools.find(el => el.model==='tool_upload')
	// 			// open_tool (tool_common)
	// 				open_tool({
	// 					tool_context	: tool_upload,
	// 					caller			: self
	// 				})
	// 		})
	// 	}

	// // quality_selector
	// 	const quality_selector = get_quality_selector(content_value, self)
	// 	content_value.appendChild(quality_selector)


	return content_value
}//end get_content_value



/**
* BUILD_3D_NODE
*
* @param string|null posterframe_url
* @return DOM node video
*/
const build_3d_node = (posterframe_url) => {

	// source tag
		const source	= document.createElement('source')
		source.type		= 'video/mp4'
		// source.src	= video_url

	// video tag
		const video		= document.createElement('video')
		video.classList.add('hide')
		if (posterframe_url) {
			video.poster = posterframe_url
		}
		video.controls	= true
		video.classList.add('posterframe')
		video.setAttribute('tabindex', 0)
		video.appendChild(source)

	// keyup event
		// video.addEventListener("timeupdate", async (e) => {
		// 	// e.stopPropagation()
		// 	// const frame = Math.floor(video.currentTime.toFixed(5) * 25);
		// })

	// canplay event
		// video.addEventListener('canplay', fn_canplay)
		// function fn_canplay() {
		// 	// self.main_component.video.removeEventListener('canplay', fn_play);
		// 	video.play()
		// }

	return video
}//end build_3D_node



/**
* GET_QUALITY_SELECTOR
*
* @param object content_value
* @return DOM node select
*/
const get_quality_selector = (content_value, self) => {

	// short vars
		const data		= self.data
		const quality	= self.quality || self.context.features.quality
		const video		= content_value.video

		const fragment = new DocumentFragment()

	// create the quality selector
		const quality_selector = ui.create_dom_element({
			element_type	: 'select',
			class_name		: 'quality_selector',
			parent			: fragment
		})
		quality_selector.addEventListener('change', (e) =>{
			const src = e.target.value
			// self.video.src = src
			video.src = src
			// event_manager.publish('image_quality_change_'+self.id, img_src)
			console.log("src:",src);
		})

		const quality_list		= data.datalist.filter(el => el.file_exist===true)
		const quality_list_len	= quality_list.length
		for (let i = 0; i < quality_list_len; i++) {
			// create the node with the all qualities sent by server
			const value = (typeof quality_list[i].file_url==='undefined')
				? '' // DEDALO_CORE_URL + "/themes/default/0.jpg"
				: quality_list[i].file_url

			const select_option = ui.create_dom_element({
				element_type	: 'option',
				value			: value,
				text_node		: quality_list[i].quality,
				parent			: quality_selector
			})
			//set the default quality_list to config variable dedalo_image_quality_default
			select_option.selected = quality_list[i].quality===quality ? true : false
		}


	return quality_selector
}//end get_quality_selector



/**
* GET_BUTTONS
* @param object instance
* @return DOM node buttons_container
*/
const get_buttons = (self) => {

	const fragment = new DocumentFragment()

	// prevent show buttons inside a tool
		if (self.caller && self.caller.type==='tool') {
			return fragment
		}

	// button_fullscreen
		const button_fullscreen = ui.create_dom_element({
			element_type	: 'span',
			class_name		: 'button full_screen',
			parent			: fragment
		})
		// button_fullscreen.addEventListener("mouseup", () =>{
		// 	self.node.classList.toggle('fullscreen')
		// 	const fullscreen_state = self.node.classList.contains('fullscreen') ? true : false
		// 	event_manager.publish('full_screen_'+self.id, fullscreen_state)
		// })
		button_fullscreen.addEventListener('click', function() {
			ui.enter_fullscreen(self.node)
		})


	// buttons tools
		ui.add_tools(self, fragment)

	// des
		// const button_info = ui.create_dom_element({
		// 	element_type	: 'span',
		// 	class_name 		: 'button full_screen',
		// 	parent 			: fragment
		// })
		// button_info.addEventListener("mouseup", async (e) =>{

		// 	const player_3d = await instances.get_instance({
		// 		model 			: 'component_3d',
		// 		section_tipo	: self.section_tipo,
		// 		section_id		: self.section_id,
		// 		tipo			: self.tipo,
		// 		context			: {},
		// 		mode 			: 'player'
		// 	})

		// 	await player_3d.build(true)

		// 	player_3d.fragment = {tc_in: 3, tc_out: 5}

		// 	const node = await player_3d.render()

		// 	// container, for every ipo will create a li node
		// 		const container = ui.create_dom_element({
		// 			element_type	: 'div'
		// 		})

		// 		self.node[0].appendChild(node)
		// })

	// buttons container
		const buttons_container = ui.component.build_buttons_container(self)
			// buttons_container.appendChild(fragment)

	// buttons_fold (allow sticky position on large components)
		const buttons_fold = ui.create_dom_element({
			element_type	: 'div',
			class_name		: 'buttons_fold',
			parent			: buttons_container
		})
		buttons_fold.appendChild(fragment)


	return buttons_container
}//end  get_buttons
