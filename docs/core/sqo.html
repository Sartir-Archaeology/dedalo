<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
</head>
<body>

<h1 id="searchqueryobject">Search Query Object</h1>

<h2 id="introduction">Introduction</h2>

<p>Search Query Object or SQO, is a JSON object to use as an abstraction of classical SQL. To create a flexible system with NoSQL and dependent on an ontology, it becomes necessary to use a flexible definition of the database query. Dédalo doesn&#8217;t have columns and we need to search data in the same way as classical SQL. We changed SQL model to NoSQL in v4 in 2012, at this time PostgreSQL(v9.2) introduced JSON format but with a very simple JSON query.</p>

<p>So we came to define a search query object, because we knew that early PostgreSQL JSON search definitions will be replaced with a more robust system. And we want to make searches compatible with ontology changes, we don&#8217;t want to use predefined searches.</p>

<h2 id="searchqueryobject-sqodefinition">Search Query Object - SQO definition</h2>

<p>./core/common/class.search_query_object.php</p>

<p><strong>search_query_object</strong> <code>object</code></p>

<p>Search Query Object defines an object with normalized properties to create a database query. Dédalo SQO definition is inspired by Mango query language interface of Apache <a href="https://docs.couchdb.org/en/stable/api/database/find.html">CouchDB</a>.</p>

<h2 id="parameters">Parameters</h2>

<ul>
<li><strong>id</strong> : <code>string</code> section_tipo and other params to define the unique id <strong>optional</strong> | ex : oh1</li>
<li><strong>section_tipo</strong> : <code>array || string</code> array of section_tipo or string with the section_tipo for search <strong>mandatory</strong> | ex : [&#8216;oh1&#8217;]</li>
<li><strong>mode</strong> : <code>string</code> (&#8216;edit&#8217; || &#8216;list&#8217; || &#8216;tm&#8217; || &#8216;related&#8217;) configure the sqo for search witch different models of matrix tables into the DDBB <strong>optional</strong> | ex : &#8216;list&#8217;</li>
<li><strong>filter</strong> : <code>object</code> definition of the filter to be apply at search <strong>optional</strong></li>
<li> <strong>operator</strong> : <code>array of objects</code> operator key define the operator (&#8216;$and&#8217; || &#8216;$or&#8217;) they are identified by the use of a dollar sign ($) prefix in the name property, array value has the arguments <code>objects</code> to be affected by operator. <strong>mandatory</strong>, <code>{&quot;$operator&quot;: [arguments]}</code>

<ul>
<li><strong>q</strong> : <code>string</code> string to search <strong>mandatory</strong>, ex: &#8216;John&#8217;</li>
<li><strong>q_operator</strong> : <code>string</code> operator to be applied to q , <strong>optional</strong>, ex: &#8216;&lt;&#8217;</li>
<li><strong>path</strong> : <code>array of objects</code> array of components creating a sequential path of the component to be searched, <strong>mandatory</strong>, ex: <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;component_tipo&quot;:&quot;oh24&quot;},{&quot;section_tipo&quot;:&quot;rsc197&quot;, &quot;component_tipo&quot;:&quot;rsc85&quot;}]}</code></li>
<li><strong>format</strong> : <code>string</code> (&#8216;direct&#8217; || &#8216;array_elements&#8217; || &#8216;typeof&#8217; || &#8216;column&#8217; || &#8216;in_column&#8217; || &#8216;function&#8217;) used to change the WHERE format <strong>optional</strong>, ex: &#8216;direct&#8217;</li>
<li><strong>use_function</strong> : <code>string</code> if format is function use_function define the PostgreSQL function to be used. <strong>optional</strong>, ex: &#8216;relations_flat_fct_st_si&#8217;</li>
<li><strong>q_split</strong> : <code>bool</code> (true || false) defines if the q need to be split into multiple WHERE queries. Default : true <strong>optional</strong>, ex: &#8216;false&#8217;</li>
<li><strong>unaccent</strong> : <code>bool</code> (true || false) defines if the q will us the unaccent function to remove accent characters in WHERE <strong>optional</strong>, ex: &#8216;false&#8217;</li>
<li><strong>type</strong> : <code>string</code> (&#8216;jsonb&#8217; || 'string) defines the type of data to be searched <strong>optional</strong>, ex: &#8216;jsonb&#8217;</li>
</ul></li>
<li> <strong>limit</strong> : <code>int</code> records limit <strong>optional</strong>, ex: 10</li>
<li> <strong>offset</strong> : <code>int</code> records offset <strong>optional</strong>, ex: 10</li>
<li> <strong>full_count</strong> : <code>bool || int</code> (true || false || 1) get the total records find . When int is passed disable the function for full count and get the number as total <strong>optional</strong>, ex: true</li>
<li> <strong>order</strong> : <code>array of objects</code> set the order of the records, every object in the array will be a column with his paths and direction <strong>optional</strong> <code>[{&quot;direction&quot;: &quot;ASC&quot;, &quot;path&quot;:[{ddo},{ddo}]}]]</code>

<ul>
<li><strong>direction</strong> : <code>string</code> (ASC || DESC) sort direction of the column <strong>optional</strong>, ex: &#8216;DESC&#8217;</li>
<li><strong>path</strong> : <code>array of objects</code> the <a href="dd_object.md">ddo</a> object that defines the path of the column beginning from the main section of the filter and path of ddo to the component in related section/s. <strong>optional</strong> <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;,&quot;component_tipo&quot;:&quot;oh24&quot;},{&quot;section_tipo&quot;:&quot;rsc197&quot;, &quot;component_tipo&quot;:&quot;rsc85&quot;}]</code></li>
</ul></li>
<li> <strong>order_custom</strong> : <code>object</code> order by specific values <strong>optional</strong>, ex: <code>{&quot;column_name&quot;: [values]}</code>

<ul>
<li><strong>column_name</strong> : <code>string</code> name of the column to be ordered <strong>optional</strong></li>
<li><strong>values</strong> : <code>array</code> the array defines the order of the values <strong>optional</strong></li>
</ul></li>
<li> <strong>filter_by_locators</strong> : <code>array of objects</code> set a order by locators, every object is a <a href="locator.md">locator</a> and the order of the array will be respected <strong>optional</strong> ex : <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;section_id&quot;:&quot;8&quot;},{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;section_id&quot;:&quot;3&quot;}]</code></li>
<li> <strong>allow_sub_select_by_id</strong> : <code>bool</code> (true || false) create a window in the SQL query to select pass the filter and get the id to select the main section default : true <strong>optional</strong> .</li>
<li> <strong>children_recursive</strong> : <code>bool</code> (true || false) filter the term of hierarchy and get the all children nodes dependents of the searched term. Default : false <strong>optional</strong></li>
<li> <strong>remove_distinct</strong> : <code>bool</code> (true || false) remove duplicates records when the SQL query has a window with multiple criteria that can get duplicate records. Default : true <strong>optional</strong></li>
<li> <strong>skip_projects_filter</strong> : <code>bool</code> (true || false) remove the mandatory filter of the component_filter applied at all users except root and global admin users. Default : false <strong>optional</strong></li>
<li> <strong>parsed</strong> : <code>bool</code> (true || false) state of the sqo, it indicates if the filter was parsed by the components to add operators to the q. It&#8217;s used as internal property, but is possible parse it manually and indicate this state. Default flase <strong>optional</strong></li>
<li> <strong>select</strong> : <code>array of objects</code> array of ddo with defines the SELECT parameter <strong>DEPRECATED DO NOT USED IN V6</strong></li>
</ul>

<h3 id="summary">Summary</h3>

<pre><code class="json">id                      : 'oh1' // optional. section_tipo and other params to define the unique id
section_tipo            : ['oh1'] // array of section_tipo for search
mode                    : ('edit' || 'list' || 'tm' || 'related') // configure the sqo for search witch different models of matrix tables into the DDBB
filter                  : {
                                operator : // string ('$and' || '$or')
                                    [{
                                        q           : '2'   // string to search
                                        q_opeator   : '&lt;'   // string || null
                                        path        : [{    // array of components creating a sequential path
                                                            section_tipo
                                                            component_tipo
                                                        }]
                                        format      : 'direct' || 'array_elements' || 'typeof' || 'column' || 'in_column' || 'function' // string, use to change the WHERE format
                                        use_function : 'relations_flat_fct_st_si' // if format is function use_function define the PostgreSQL function to be used.
                                        q_split     : true || false // bool, define if the q need to be split into multiple WHERE queries
                                        unaccent    : true || false // bool, define if the q will us the unaccent function in WHERE
                                        type        : 'jsonb' || 'string' // define the type of data to be searched
                                    }]
                            } || null
limit                   : 1 // int
offset                  : 2 // int
full_count              : (true || false || 4) // boolean or int (int disable the function for full count and get the number as total)
order                   : [{
                                direction   : (ASC || DESC) // string
                                path        : [{
                                    section_tipo
                                    component_tipo
                                }]
                            }]
order_custom            : {
                            column_name : [values]
                            }
filter_by_locators      : [{
                                section_tipo
                                component_tipo
                            }]
allow_sub_select_by_id  : (true || false) // default true
children_recursive      : (true || false) // default false
remove_distinct         : (true || false) // default true
skip_projects_filter    : (true || false) // default false
parsed                  : (true || false) // boolean, state of the sqo | default false
select                  : [{    //DEPRECATED | array of objects optional
                            section_tipo
                            component_tipo
                        }]
</code></pre>

<h2 id="usingsqo">Using SQO</h2>

<p>Search Query Object is used to get data from database. It use section_tipo to point specific section/s to get data and it use ddo to define the properties to be searched in q.</p>

<p>If you want to get any person with name &#8220;Ana&#8221; the sqo will be:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: &quot;rsc197&quot;,
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;Ana&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;rsc197&quot;,
            &quot;component_tipo&quot;: &quot;rsc85&quot;
          }]
      }]
  }
}
</code></pre>

<p>The SQO say: search in people under study (section_tipo <a href="https://dedalo.dev/ontology/rsc197">rsc197</a>) with the path to name field (component_tipo <a href="https://dedalo.dev/ontology/rsc85">rsc85</a>) with the Ana text. SQO will parse the filter with the component_input_text rsc85 and will render into SQL to be used in postgreSQL:</p>

<pre><code class="sql">
SELECT DISTINCT ON (rs197.section_id) rs197.section_id,
rs197.section_tipo,
rs197.datos
FROM matrix AS rs197
WHERE rs197.id in (
    SELECT DISTINCT ON(rs197.section_id,rs197.section_tipo) rs197.id 
    FROM matrix AS rs197
    WHERE (
            rs197.section_tipo='rsc197') AND 
            rs197.section_id&gt;0  AND 
            (f_unaccent(rs197.datos#&gt;&gt;'{components,rsc86,dato}') ~* f_unaccent('.*\[&quot;.*Ana.*'))
    ORDER BY rs197.section_id ASC
    LIMIT 10
)
ORDER BY rs197.section_id ASC
LIMIT 10;

</code></pre>

<h2 id="definitions">Definitions</h2>

<h3 id="id">id</h3>

<p>The property id is used to identify a SQO in the process to build, send and retrieve information from server.</p>

<p>In Dédalo API calls it&#8217;s possible send multiple request and it&#8217;s necessary a way to identify the original SQO with the result. The property id is used to this function.</p>

<p>Example: Search &#8216;Ana&#8217; in the field name <a href="https://dedalo.dev/ontology/rsc85">rsc85</a> of the section People under study <a href="https://dedalo.dev/ontology/rsc197">rsc197</a></p>

<pre><code class="json">{
  &quot;id&quot;: &quot;my_id_for_the_request&quot;,
  &quot;section_tipo&quot;: &quot;rsc197&quot;,
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;Ana&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;rsc197&quot;,
            &quot;component_tipo&quot;: &quot;rsc85&quot;
          }]
      }]
  }
}
</code></pre>

<h3 id="section_tipomandatory">section_tipo <em>mandatory</em></h3>

<p>Defines the section/s of the search. It can be a string when the search is for one section or it can be array when the search is with multiple sections as toponymy search in multiple countries as Spain, France, &#8230; (es1, fr1, &#8230;).</p>

<p>Definition : <code>array || string</code> array of section_tipo or string with the section_tipo for search <strong>mandatory</strong> | ex : [&#8216;oh1&#8217;]</p>

<p>Section is a mandatory property, it define where we want to do the search, where the data is that we are looking for.
Is possible use a string or array when the section to search is only one, but it&#8217;s recommendable to use always a array definition. Using the array is extensible and it&#8217;s possible add new section easily.</p>

<p>Example with one section: Search &#8216;87C_g25&#8217; in the field Code <a href="https://dedalo.dev/ontology/oh14">oh14</a> of the section Oral History <a href="https://dedalo.dev/ontology/oh1">oh1</a></p>

<pre><code class="json">{
  &quot;section_tipo&quot;: &quot;oh1&quot;,
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;87C_g25&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;oh1&quot;,
            &quot;component_tipo&quot;: &quot;oh14&quot;
          }]
      }]
  }
}
</code></pre>

<p>Example with multiple sections: Search &#8216;Benimamet&#8217; in the field Term <a href="https://dedalo.dev/ontology/hierarchy25">hierarchy25</a> of the sections Spain es1 and France fr1</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [&quot;es1&quot;, &quot;fr1&quot;],
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;Benimamet&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;es1&quot;,
            &quot;component_tipo&quot;: &quot;hierarchy25&quot;
          },{
            &quot;section_tipo&quot;: &quot;fr1&quot;,
            &quot;component_tipo&quot;: &quot;hierarchy25&quot;
          }]
      }]
  }
}
</code></pre>

<p>In previous example, the section_tipo is an array: <code>[&quot;es1&quot;, &quot;fr1&quot;]</code> with multiple sections to be searched. This kind of search could be useful to use in multiple situations, and it could be used with mixed fields, the sections has not to be equals (in these situations Dédalo do not create a UNION SQL, it will resolve as a normal WHERE statement)</p>

<h4 id="all">all</h4>

<p>In some cases is not possible to define the section_tipo to be searcher because you want to get any result in any place that match with your query. For this situations is possible to define the section_tipo as <code>all</code>. The result will be; all sections fonded with the query. Take account that the result will be not consistent, every section will have his own components(fields).</p>

<p>Example with multiple sections, using <code>all</code> section: Search &#8216;Benimamet&#8217; in the field Term <a href="https://dedalo.dev/ontology/hierarchy25">hierarchy25</a> of all sections.</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [&quot;all&quot;],
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;Benimamet&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;all&quot;,
            &quot;component_tipo&quot;: &quot;hierarchy25&quot;
          }
      }]
  }
}
</code></pre>

<p>the result here could be:</p>

<pre><code class="json">{&quot;result:[
  {

  }
]}
</code></pre>

<h3 id="mode">mode</h3>

<p>Defines what kind of search will be done, in previous version yo v5 mode was used to create the lists or the edit views of the search, but, after v6, mode property is using to define the type of the search, if the search is in time machine or regular matrix tables or if you want search in hierarchies (to get children) or you want get the relations instead to get the main section search.</p>

<p>Definition: <code>string</code> (&#8216;edit&#8217; || &#8216;list&#8217; || &#8216;tm&#8217; || &#8216;related&#8217;) configure the sqo for search witch different models of matrix tables into the DDBB <strong>optional</strong> | ex : &#8216;list&#8217;</p>

<p>Example with one section: Search &#8216;87C_g25&#8217; in the field Code <a href="https://dedalo.dev/ontology/oh14">oh14</a> of the section Oral History <a href="https://dedalo.dev/ontology/oh1">oh1</a></p>

<pre><code class="json">{
  &quot;section_tipo&quot;: &quot;oh1&quot;,
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;87C_g25&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;oh1&quot;,
            &quot;component_tipo&quot;: &quot;oh14&quot;
          }]
      }]
  }
}
</code></pre>

<h3 id="filter">filter</h3>

<p>Filter object defines the properties to be applied to the search, filter options will be interpreted in the same way than SQL WHERE clause.
Filter will be interpreted by any component to apply hiw own rules so filter has two states, parsed or not, when the SQO, by default filter is un parsed, because when create a new sqo it&#8217;s not possible to identified the operators or data forms of every component, and the filter need to be created in the same way to different situations, when the sqo is send to the Dédalo server, every component will interpreted his part of the search and parse his own part to the final format.</p>

<p>Definition: <code>object</code> definition of the filter to be apply at search <strong>optional</strong></p>

<h4 id="operator">operator</h4>

<p>Defines which boolean operator will be applied to the query. Operator is an array or queries objects, every query object has his own properties and the operator will be applied between every of this query objects.</p>

<p>Definition : <code>array of objects</code> operator key define the operator (&#8216;$and&#8217; || &#8216;$or&#8217;) they are identified by the use of a dollar sign ($) prefix in the name property, array value has the arguments <code>objects</code> to be affected by operator. <strong>mandatory</strong>, <code>{&quot;$operator&quot;: [arguments]}</code></p>

<p>The filter object need to has at least one operator defined as property of the object. By default, &#8216;AND&#8217; operator is added as <code>$and</code> key of the filter object.</p>

<p>Example to search with <code>$and</code> operator :</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$and&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  }]
}
</code></pre>

<p>It will be parsed as SQL WHERE sentence like:</p>

<pre><code class="sql">...
  WHERE q = &quot;Isis&quot;
... 
</code></pre>

<p>And some other filter items could be added as objects in array, ex with <code>$or</code>operator:</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$or&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  },
  {
    &quot;q&quot; : &quot;Raspa&quot;
  }]
}
</code></pre>

<p>It will be parsed as SQL WHERE sentence like:</p>

<pre><code class="sql">...
  WHERE (q = 'Isis') OR (q = 'Raspa')
... 
</code></pre>

<p>And nested operators could be added:</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$or&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  },
  {
    &quot;q&quot; : &quot;Raspa&quot;
  },
  {
    &quot;$and&quot; : [{
      &quot;q&quot; : &quot;Osiris&quot;
    }]
  }]
}
</code></pre>

<p>So nested operations will be parsed as SQL WHERE sentence like:</p>

<pre><code class="sql">...
  WHERE ((q = 'Isis' OR q = 'Raspa') AND q = 'Osiris')
... 
</code></pre>

<p>!!! Note: &#8220;Use of q name&#8221;
In the examples q name is used as SQL column name to better comprehension, but in real SQL parsed search, q column is not used, it need to be a component path or relation path.</p>

<h5 id="q">q</h5>

<p>Defines the value (literal or locator) to be searcher. &#8216;q&#8217; property (as query) has two states: first, &#8216;q&#8217; has the value that user input in the client user interface, and second one when this data was parsed after component analyze the operators to add some modifications into the literal format, or in the case of q is a locator, it will analyze to add some properties to adapt q to the user want to search foe ex: time machine or inverse mode.</p>

<p>Definition : <code>string</code> string to search <strong>mandatory</strong>, ex: &#8216;John&#8217;</p>

<p>To define a filter to search &#8216;Isis&#8217; name</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$and&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  }]
}
</code></pre>

<pre><code class="mermaid">    graph LR
    A((Filter user interface :: search.js | q='orange cat')) --is send to--&gt; B((API :: read ))
    B --is send to--&gt; C((search :: search ))
    C --is send to--&gt; D((search :: pre_parse_search_query_object() ))
    D --is send to--&gt; E((search :: conform_search_query_object() ))
    E --is send to--&gt; F((component :: get_search_query() ))
    G --true--&gt; H((component :: get_search_query() ))
    G --false--&gt; H((component :: return(q='orange cat')) ))
</code></pre>

</body>
</html>

