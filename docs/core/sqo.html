<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
</head>
<body>

<h1 id="searchqueryobject">Search Query Object</h1>

<h2 id="introduction">Introduction</h2>

<p>Search Query Object or SQO, is a JSON object to use as an abstraction of classical SQL. To create a flexible system with NoSQL and dependent on an ontology, it becomes necessary to use a flexible definition of the database query. Dédalo doesn&#8217;t have columns and we need to search data in the same way as classical SQL. We changed SQL model to NoSQL in v4 in 2012, at this time PostgreSQL(v9.2) introduced JSON format but with a very simple JSON query.</p>

<p>So we came to define a search query object, because we knew that early PostgreSQL JSON search definitions will be replaced with a more robust system. And we want to make searches compatible with ontology changes, we don&#8217;t want to use predefined searches.</p>

<h2 id="searchqueryobject-sqodefinition">Search Query Object - SQO definition</h2>

<p>./core/common/class.search_query_object.php</p>

<p><strong>search_query_object</strong> <code>object</code></p>

<p>Search Query Object defines an object with normalized properties to create a database query. Dédalo SQO definition is inspired by Mango query language interface of Apache <a href="https://docs.couchdb.org/en/stable/api/database/find.html">CouchDB</a>.</p>

<h2 id="searchflow">Search flow</h2>

<p>Search Query Object is send as part of Request Query Object to be processed by server API, the Search Query Object is parsed by Search Class and processed by every component involve into the query, the SQO parsed will be used to create the final SQL to be sent to the DDBB. The final result will send to client in JSON format.</p>

<pre><code class="mermaid">    graph TD
    A([&quot;User  search 
     {q='orange cat'}&quot;]) -- RQO with SQO--&gt; B
    B((&quot;API :: read()
    action : search&quot;))
    B --SQO--&gt; C((&quot;search :: search()&quot; ))
    C --is send to preparse--&gt; D(&quot;search :: pre_parse_search_query_object()&quot; )
    D-- result preparsed --&gt;C
    D --is send to--&gt; E(&quot;search :: conform_search_query_object()&quot; )
    E-- result --&gt;D
    E --is send to--&gt; F(&quot;component_common :: get_search_query()&quot; )
    F-- result --&gt;E
    F-- is send to --&gt;G
    G(&quot;component :: resolve_query_object_sql() 
      q='orange'&quot;)
    F-- is send to --&gt;H
    H(&quot;component :: resolve_query_object_sql() 
      q='cat' &quot;)
    G-- result --&gt;F
    H-- result --&gt;F
    C-- wait for preparse--&gt; I(&quot;search :: parse_search_query_object()&quot; )
    I--SQL--&gt; J(&quot;JSON_RecordOBJ_matrix :: search_free()&quot; )
    J--SQL--&gt;Q[(matrix tables)]
    Q --PgSql\Result--&gt; K{{&quot;result :: 
    {ar_records:[{'Raspa'}]}&quot;}}
    K --Object--&gt; B
    B --JSON--&gt; A
</code></pre>

<h2 id="parameters">Parameters</h2>

<ul>
<li><strong>id</strong> : <code>string</code> section_tipo and other params to define the unique id <strong>optional</strong> | ex : oh1</li>
<li><strong>section_tipo</strong> : <code>array || string</code> array of section_tipo or string with the section_tipo for search <strong>mandatory</strong> | ex : <code>['oh1']</code></li>
<li><strong>mode</strong> : <code>string</code> (&#8216;edit&#8217; || &#8216;list&#8217; || &#8216;tm&#8217; || &#8216;related&#8217;) configure the sqo for search witch different models of matrix tables into the DDBB <strong>optional</strong> | ex : &#8216;list&#8217;</li>
<li><strong>filter</strong> : <code>object</code> definition of the filter to be apply at search <strong>optional</strong></li>
<li> <strong>operator</strong> : <code>array of objects</code> operator key define the operator (&#8216;$and&#8217; || &#8216;$or&#8217;) they are identified by the use of a dollar sign ($) prefix in the name property, array value has the arguments <code>objects</code> to be affected by operator. <strong>mandatory</strong>, <code>{&quot;$operator&quot;: [arguments]}</code>

<ul>
<li><strong>q</strong> : <code>string</code> string to search <strong>mandatory</strong>, ex: &#8216;John&#8217;</li>
<li><strong>q_operator</strong> : <code>string</code> operator to be applied to q , <strong>optional</strong>, ex: &#8216;&lt;&#8217;</li>
<li><strong>path</strong> : <code>array of objects</code> array of components creating a sequential path of the component to be searched, <strong>mandatory</strong>, ex: <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;component_tipo&quot;:&quot;oh24&quot;},{&quot;section_tipo&quot;:&quot;rsc197&quot;, &quot;component_tipo&quot;:&quot;rsc85&quot;}]}</code></li>
<li><strong>format</strong> : <code>string</code> (&#8216;direct&#8217; || &#8216;array_elements&#8217; || &#8216;typeof&#8217; || &#8216;column&#8217; || &#8216;in_column&#8217; || &#8216;function&#8217;) used to change the WHERE format <strong>optional</strong>, ex: &#8216;direct&#8217;</li>
<li><strong>use_function</strong> : <code>string</code> if format is function use_function define the PostgreSQL function to be used. <strong>optional</strong>, ex: &#8216;relations_flat_fct_st_si&#8217;</li>
<li><strong>q_split</strong> : <code>bool</code> (true || false) defines if the q need to be split into multiple WHERE queries. Default : true <strong>optional</strong>, ex: &#8216;false&#8217;</li>
<li><strong>unaccent</strong> : <code>bool</code> (true || false) defines if the q will us the unaccent function to remove accent characters in WHERE <strong>optional</strong>, ex: &#8216;false&#8217;</li>
<li><strong>type</strong> : <code>string</code> (&#8216;jsonb&#8217; || 'string) defines the type of data to be searched <strong>optional</strong>, ex: &#8216;jsonb&#8217;</li>
</ul></li>
<li><strong>limit</strong> : <code>int</code> records limit <strong>optional</strong>, ex: 10</li>
<li><strong>offset</strong> : <code>int</code> records offset <strong>optional</strong>, ex: 10</li>
<li><strong>full_count</strong> : <code>bool || int</code> (true || false || 1) get the total records find . When int is passed disable the function for full count and get the number as total <strong>optional</strong>, ex: true</li>
<li><strong>order</strong> : <code>array of objects</code> set the order of the records, every object in the array will be a column with his paths and direction <strong>optional</strong> <code>[{&quot;direction&quot;: &quot;ASC&quot;, &quot;path&quot;:[{ddo},{ddo}]}]]</code></li>
<li> <strong>direction</strong> : <code>string</code> (ASC || DESC) sort direction of the column <strong>optional</strong>, ex: &#8216;DESC&#8217;</li>
<li> <strong>path</strong> : <code>array of objects</code> the <a href="dd_object.md">ddo</a> object that defines the path of the column beginning from the main section of the filter and path of ddo to the component in related section/s. <strong>optional</strong> <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;,&quot;component_tipo&quot;:&quot;oh24&quot;},{&quot;section_tipo&quot;:&quot;rsc197&quot;, &quot;component_tipo&quot;:&quot;rsc85&quot;}]</code></li>
<li><strong>order_custom</strong> : <code>object</code> order by specific values <strong>optional</strong>, ex: <code>[{&quot;section_tipo&quot;: section_tipo, &quot;column_name&quot;: column_name, &quot;column_values&quot;: [values]}}</code></li>
<li> <strong>section_tipo</strong> : <code>string</code> name of section to be used to be ordered <strong>optional</strong></li>
<li> <strong>column_name</strong> : <code>string</code> name of the column to be ordered <strong>optional</strong></li>
<li> <strong>column_values</strong> : <code>array</code> the array defines the order of the values <strong>optional</strong></li>
<li><strong>filter_by_locators</strong> : <code>array of objects</code> set a order by locators, every object is a <a href="locator.md">locator</a> and the order of the array will be respected <strong>optional</strong> ex : <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;section_id&quot;:&quot;8&quot;},{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;section_id&quot;:&quot;3&quot;}]</code></li>
<li><strong>allow_sub_select_by_id</strong> : <code>bool</code> (true || false) create a sub select in the SQL query to select pass the filter and get the id to select the main section default : true <strong>optional</strong> .</li>
<li><strong>children_recursive</strong> : <code>bool</code> (true || false) filter the term of hierarchy and get the all children nodes dependents of the searched term. Default : false <strong>optional</strong></li>
<li><strong>remove_distinct</strong> : <code>bool</code> (true || false) remove duplicates records when the SQL query has a sub select with multiple criteria that can get duplicate records. Default : false <strong>optional</strong></li>
<li><strong>skip_projects_filter</strong> : <code>bool</code> (true || false) remove the mandatory filter of the component_filter applied at all users except root and global admin users. Default : false <strong>optional</strong></li>
<li><strong>parsed</strong> : <code>bool</code> (true || false) state of the sqo, it indicates if the filter was parsed by the components to add operators to the q. It&#8217;s used as internal property, but is possible parse it manually and indicate this state. Default false <strong>optional</strong></li>
<li><strong>select</strong> : <code>array of objects</code> array of ddo with defines the SELECT parameter <strong>DEPRECATED DO NOT USED IN V6</strong></li>
</ul>

<h3 id="summary">Summary</h3>

<pre><code class="json">id                      : 'oh1' // optional. section_tipo and other params to define the unique id
section_tipo            : ['oh1'] // array of section_tipo for search
mode                    : ('edit' || 'list' || 'tm' || 'related') // configure the sqo for search witch different models of matrix tables into the DDBB
filter                  : {
                                operator : // string ('$and' || '$or')
                                    [{
                                        q           : '2'   // string to search
                                        q_opeator   : '&lt;'   // string || null
                                        path        : [{    // array of components creating a sequential path
                                                            section_tipo
                                                            component_tipo
                                                        }]
                                        format      : 'direct' || 'array_elements' || 'typeof' || 'column' || 'in_column' || 'function' // string, use to change the WHERE format
                                        use_function : 'relations_flat_fct_st_si' // if format is function use_function define the PostgreSQL function to be used.
                                        q_split     : true || false // bool, define if the q need to be split into multiple WHERE queries
                                        unaccent    : true || false // bool, define if the q will us the unaccent function in WHERE
                                        type        : 'jsonb' || 'string' // define the type of data to be searched
                                    }]
                            } || null
limit                   : 1 // int
offset                  : 2 // int
full_count              : (true || false || 4) // boolean or int (int disable the function for full count and get the number as total)
order                   : [{
                                direction   : (ASC || DESC) // string
                                path        : [{
                                    section_tipo
                                    component_tipo
                                }]
                            }]
order_custom            : {
                            column_name : [values]
                            }
filter_by_locators      : [{
                                section_tipo
                                component_tipo
                            }]
allow_sub_select_by_id  : (true || false) // default true
children_recursive      : (true || false) // default false
remove_distinct         : (true || false) // default false
skip_projects_filter    : (true || false) // default false
parsed                  : (true || false) // boolean, state of the sqo | default false
select                  : [{    //DEPRECATED | array of objects optional
                            section_tipo
                            component_tipo
                        }]
</code></pre>

<h2 id="usingsqo">Using SQO</h2>

<p>Search Query Object is used to get data from database. It use section_tipo to point specific section/s to get data and it use ddo to define the properties to be searched in q.</p>

<p>If you want to get any person with name &#8220;Ana&#8221; the sqo will be:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: &quot;rsc197&quot;,
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;Ana&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;rsc197&quot;,
            &quot;component_tipo&quot;: &quot;rsc85&quot;
          }]
      }]
  }
}
</code></pre>

<p>The SQO say: search in people under study (section_tipo <a href="https://dedalo.dev/ontology/rsc197">rsc197</a>) with the path to name field (component_tipo <a href="https://dedalo.dev/ontology/rsc85">rsc85</a>) with the Ana text. SQO will parse the filter with the component_input_text rsc85 and will render into SQL to be used in postgreSQL:</p>

<pre><code class="sql">
SELECT DISTINCT ON (rs197.section_id) rs197.section_id,
rs197.section_tipo,
rs197.datos
FROM matrix AS rs197
WHERE rs197.id in (
    SELECT DISTINCT ON(rs197.section_id,rs197.section_tipo) rs197.id 
    FROM matrix AS rs197
    WHERE (
            rs197.section_tipo='rsc197') AND 
            rs197.section_id&gt;0  AND 
            (f_unaccent(rs197.datos#&gt;&gt;'{components,rsc86,dato}') ~* f_unaccent('.*\[&quot;.*Ana.*'))
    ORDER BY rs197.section_id ASC
    LIMIT 10
)
ORDER BY rs197.section_id ASC
LIMIT 10;

</code></pre>

<h2 id="definitions">Definitions</h2>

<h3 id="id">id</h3>

<p>The property id is used to identify a SQO in the process to build, send and retrieve information from server.</p>

<p>In Dédalo API calls it&#8217;s possible send multiple request and it&#8217;s necessary a way to identify the original SQO with the result. The property id is used to this function.</p>

<p>Example: Search &#8216;Ana&#8217; in the field name <a href="https://dedalo.dev/ontology/rsc85">rsc85</a> of the section People under study <a href="https://dedalo.dev/ontology/rsc197">rsc197</a></p>

<pre><code class="json">{
  &quot;id&quot;: &quot;my_id_for_the_request&quot;,
  &quot;section_tipo&quot;: &quot;rsc197&quot;,
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;Ana&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;rsc197&quot;,
            &quot;component_tipo&quot;: &quot;rsc85&quot;
          }]
      }]
  }
}
</code></pre>

<h3 id="section_tipomandatory">section_tipo <em>mandatory</em></h3>

<p>Defines the section/s of the search. It can be a string when the search is for one section or it can be array when the search is with multiple sections as toponymy search in multiple countries as Spain, France, &#8230; (es1, fr1, &#8230;).</p>

<p>Definition : <code>array || string</code> array of section_tipo or string with the section_tipo for search <strong>mandatory</strong> | ex : <code>['oh1']</code></p>

<p>Section is a mandatory property, it define where we want to do the search, where the data is that we are looking for.
Is possible use a string or array when the section to search is only one, but it&#8217;s recommendable to use always a array definition. Using the array is extensible and it&#8217;s possible add new section easily.</p>

<p>Example with one section: Search &#8216;87C_g25&#8217; in the field Code <a href="https://dedalo.dev/ontology/oh14">oh14</a> of the section Oral History <a href="https://dedalo.dev/ontology/oh1">oh1</a></p>

<pre><code class="json">{
  &quot;section_tipo&quot;: &quot;oh1&quot;,
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;87C_g25&quot;,
        &quot;path&quot;: [{
            &quot;section_tipo&quot;: &quot;oh1&quot;,
            &quot;component_tipo&quot;: &quot;oh14&quot;
          }]
      }]
  }
}
</code></pre>

<p>Example with multiple sections: Search &#8216;Benimamet&#8217; in the field Term <a href="https://dedalo.dev/ontology/hierarchy25">hierarchy25</a> of the sections Spain es1 and France fr1</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [&quot;es1&quot;, &quot;fr1&quot;],
  &quot;filter&quot;: {
    &quot;$and&quot;: [{
        &quot;q&quot;: &quot;Benimamet&quot;,
        &quot;path&quot;: [
            {
              &quot;section_tipo&quot;: &quot;es1&quot;,
              &quot;component_tipo&quot;: &quot;hierarchy25&quot;
            },{
              &quot;section_tipo&quot;: &quot;fr1&quot;,
              &quot;component_tipo&quot;: &quot;hierarchy25&quot;
            }
          ]
      }]
  }
}
</code></pre>

<p>In previous example, the section_tipo is an array: <code>[&quot;es1&quot;, &quot;fr1&quot;]</code> with multiple sections to be searched. This kind of search could be useful to use in multiple situations, and it could be used with mixed fields, the sections has not to be equals (in these situations Dédalo do not create a UNION SQL, it will resolve as a normal WHERE statement)</p>

<h4 id="all">all</h4>

<p>In some cases is not possible to define the section_tipo to be searcher because you want to get any result in any place that match with your query. For this situations is possible to define the section_tipo as <code>all</code>. The result will be; all sections fonded with the query. Take account that the result will be not consistent, every section will have his own components(fields).</p>

<p>Example with multiple sections, using <code>all</code> section: Search &#8216;Benimamet&#8217; in the field Term <a href="https://dedalo.dev/ontology/hierarchy25">hierarchy25</a> of all sections.</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [&quot;all&quot;],
  &quot;mode&quot;: &quot;related&quot;,
  &quot;filter_by_locators&quot; : [{
    &quot;section_tipo&quot; : &quot;rsc197&quot;,
    &quot;section_id&quot; : &quot;2&quot;
  }]
  }
</code></pre>

<p>the result will be a mix of data from different sections:</p>

<pre><code class="json">{
  &quot;result&quot;:[
    {
      &quot;section_tipo&quot; : &quot;oh1&quot;,
      &quot;section_id&quot; : &quot;2&quot;
      &quot;datos&quot;:{
        &quot;components&quot;:{
          &quot;oh16&quot;:{
            &quot;inf&quot;: &quot;Title&quot;,
            &quot;dato&quot;: {
              &quot;lg-spa&quot;: &quot;my second interview&quot;
            }
          }
        }
      }
    },
    {
      &quot;section_tipo&quot; : &quot;rsc197&quot;,
      &quot;section_id&quot; : &quot;88&quot;
      &quot;datos&quot;:{
        &quot;relations&quot;:[{
          &quot;section_tipo&quot; : &quot;rsc197&quot;,
          &quot;section_id&quot; : &quot;2&quot;
        }]
      }
    }
  ]
}
</code></pre>

<h3 id="mode">mode</h3>

<p>Defines what kind of search will be done, in previous versions to v6 mode was used to create the lists or the edit views of the search, but, after v6, mode property is using to define the type of the search, if the search is in time machine or regular matrix tables or if you want search in hierarchies (to get children) or you want get the relations instead to get the main section search.</p>

<p>Definition: <code>string</code> (&#8216;edit&#8217; || &#8216;list&#8217; || &#8216;tm&#8217; || &#8216;related&#8217;) configure the sqo for search witch different models of matrix tables into the DDBB <strong>optional</strong> | ex : &#8216;list&#8217;</p>

<p>Example: give me the time machine of the Oral History section <a href="https://dedalo.dev/ontology/oh1">oh1</a></p>

<pre><code class="json">{
  &quot;section_tipo&quot;: &quot;oh1&quot;,
  &quot;mode&quot;: &quot;tm&quot;,
  &quot;order&quot; : [{
    &quot;direction&quot; : &quot;DESC&quot;,
    &quot;path&quot; : [
      { 
        &quot;component_tipo&quot; : &quot;id&quot; 
      }
      ]
  }]
}
</code></pre>

<h3 id="filter">filter</h3>

<p>Filter object defines the properties to be applied to the search, filter options will be interpreted in the same way than SQL WHERE clause.</p>

<p>Filter will be parsed by the components to apply his own rules, therefore filter has two states, parsed or not. By default filter is unparsed because when create a new sqo it&#8217;s not possible to identified the operators or data forms of every component, and the filter need to be created in the same way to different situations, when the sqo is send to the Dédalo server, every component will interpreted his part of the search and parse his own part to the final format, and the filter will change to parse state.</p>

<p>In some cases the filter property is not necessary to be set, such as time machine searches, in these cases the sqo interprets that it is necessary to obtain all the data.</p>

<p>Definition: <code>object</code> definition of the filter to be apply at search <strong>optional</strong></p>

<p>The filter is a object with at least one boolean operator as first property:</p>

<h4 id="operator">operator</h4>

<p>Defines which boolean operator will be applied to the query. Operator is an array or queries objects, every query object has his own properties and the operator will be applied between every of this query objects.</p>

<p>Definition : <code>array of objects</code> operator key define the operator (&#8216;$and&#8217; || &#8216;$or&#8217;) they are identified by the use of a dollar sign ($) prefix in the name property, array value has the arguments <code>objects</code> to be affected by operator. <strong>mandatory</strong>, <code>{&quot;$operator&quot;: [arguments]}</code></p>

<p>!!! note &#8220;About the mandatory of the operator&#8221;
This property is dependent of the filter. When the filter is present into the SQO the operator is mandatory, if the filter is not present it&#8217;s not necessary define one operator.</p>

<p>The filter object need to has at least one operator defined as property of the object. By default, &#8216;AND&#8217; operator is added as <code>$and</code> key of the filter object.</p>

<p>Example to search with <code>$and</code> operator :</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$and&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  }]
}
</code></pre>

<p>It will be parsed as SQL WHERE sentence like:</p>

<pre><code class="sql">...
  WHERE q = &quot;Isis&quot;
... 
</code></pre>

<p>And some other filter items could be added as objects in array, ex with <code>$or</code>operator:</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$or&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  },
  {
    &quot;q&quot; : &quot;Raspa&quot;
  }]
}
</code></pre>

<p>It will be parsed as SQL WHERE sentence like:</p>

<pre><code class="sql">...
  WHERE (q = 'Isis') OR (q = 'Raspa')
... 
</code></pre>

<p>And nested operators could be added:</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$or&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  },
  {
    &quot;q&quot; : &quot;Raspa&quot;
  },
  {
    &quot;$and&quot; : [{
      &quot;q&quot; : &quot;Osiris&quot;
    }]
  }]
}
</code></pre>

<p>So nested operations will be parsed as SQL WHERE sentence like:</p>

<pre><code class="sql">...
  WHERE ((q = 'Isis' OR q = 'Raspa') AND q = 'Osiris')
... 
</code></pre>

<p>!!! note &#8220;Use of q name&#8221;
In the examples q name is used as SQL column name to better comprehension, but in real SQL parsed search, q column is not used, it need to be a component path or relation path.</p>

<h5 id="q">q</h5>

<p>Defines the value (literal or locator) to be searcher. &#8216;q&#8217; property (as query) has two states: first, &#8216;q&#8217; has the value that user input in the client user interface, and second one when this data was parsed after component analyze the operators to add some modifications into the literal format, or in the case of q is a locator, it will analyze to add some properties to adapt q to the user want to search foe ex: time machine or inverse mode.</p>

<p>Definition : <code>string</code> string to search <strong>mandatory</strong>, ex: &#8216;John&#8217;</p>

<p>To define a filter to search &#8216;Isis&#8217; name</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$and&quot;:[{
    &quot;q&quot; : &quot;Isis&quot;
  }]
}
</code></pre>

<p>When the component to search is a input type text (such as component_text_area or component_input_text) q property could has operator inside the text. Every component defines his own operators as: begins, equal, etc.</p>

<p>To define a filter to search any word that begins by &#8216;Is&#8217; the operator will be: &#8216;Is*&#8217;</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$and&quot;:[{
    &quot;q&quot; : &quot;Is*&quot;
  }]
}
</code></pre>

<h5 id="q_operator">q_operator</h5>

<p>Defines the operator to be used in components that has not an input type text. Some components, as selects, radio buttons, or portals, etc, has not a input to write the value to search, this kind of components use a parallel input text to define the operator to be used in combination of component data, the value of this input text is set to q_operator property.</p>

<p>Definition : <code>string</code> operator to be applied to q , <strong>optional</strong>, ex: &#8216;&lt;&#8217;</p>

<p>Example: find if the component has some value</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$and&quot;:[{
    &quot;q_opeator&quot; : &quot;*&quot;
  }]
}
</code></pre>

<p>Example: find if the component doesn&#8217;t has any value</p>

<pre><code class="json">&quot;filter&quot;:{
  &quot;$and&quot;:[{
    &quot;q_opeator&quot; : &quot;!*&quot;
  }]
}
</code></pre>

<h5 id="path">path</h5>

<p>Defines the path to the search component from current section. Sometimes the component to be searched could be linked by any portal (with a locator) so the component is not inside the current section, it&#8217;s in other section and in this case SQO need follow the path to find the component. The path defines the deep into linked data sections.</p>

<p>Definition: <code>array of objects</code> an array of components creating a sequential path of the component to be searched, <strong>mandatory</strong>, ex: <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;,&quot;component_tipo&quot;:&quot;oh24&quot;},{&quot;section_tipo&quot;:&quot;rsc197&quot;, &quot;component_tipo&quot;:&quot;rsc85&quot;}]}</code></p>

<p>See this situation:</p>

<pre><code class="mermaid">    graph LR
    A((&quot;Oral History :: section&quot;))--&gt;B(Informants :: component_portal)
    B--&gt;C((&quot;People under study :: section&quot;))
</code></pre>

<p>The Oral History section <a href="https://dedalo.dev/ontology/rsc85">rsc85</a> is linked to People under study section <a href="https://dedalo.dev/ontology/rsc197">rsc197</a> by the component Informants <a href="https://dedalo.dev/ontology/oh24">oh24</a>.</p>

<p>!!! note &#8220;SQL equivalence&#8221;
Path is equivalent to JOIN statement into SQL, the sections are equivalent to tables and the components are the columns that linked this tables.</p>

<p>To search interviews of informants born in 1928 the SQO should follow previous path to locate the date of birth component <a href="https://dedalo.dev/ontology/rsc89">rsc89</a>.</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [&quot;oh1&quot;],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: [
                  {
                      &quot;mode&quot;: &quot;start&quot;,
                      &quot;start&quot;: {
                          &quot;year&quot;: 1928
                      }
                  }
              ],
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;oh1&quot;,
                      &quot;component_tipo&quot;: &quot;oh24&quot;,
                      &quot;model&quot;: &quot;component_portal&quot;,
                      &quot;name&quot;: &quot;Informants&quot;
                  },
                  {
                      &quot;section_tipo&quot;: &quot;rsc197&quot;,
                      &quot;component_tipo&quot;: &quot;rsc89&quot;,
                      &quot;model&quot;: &quot;component_date&quot;,
                      &quot;name&quot;: &quot;Date of birth&quot;
                  }
              ]
          }
      ]
  }
}
</code></pre>

<p>The last object of the path will be used to search the value of the query. The result data will be the interviews (in oral history section) that match with the query.</p>

<h5 id="format">format</h5>

<p>Defines the parse method to be applied to the SQO when it is transform into SQL.</p>

<p>SQO can be interpreted as different SQL with different uses, the format property control how will be parsed and witch kind of search perform.</p>

<p>Definition : <code>string</code> (&#8216;direct&#8217; || &#8216;array_elements&#8217; || &#8216;typeof&#8217; || &#8216;column&#8217; || &#8216;in_column&#8217; || &#8216;function&#8217;) used to change the WHERE format <strong>optional</strong>, ex: &#8216;direct&#8217;</p>

<p>Example: search the id&#8217;s 1 and 6 of interviews <a href="https://dedalo.dev/ontology/oh1">oh1</a>.</p>

<p>1.- format &#8220;column&#8221;:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;oh1&quot; ],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: [ &quot;1,6&quot; ],
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;oh1&quot;,
                      &quot;component_tipo&quot;: &quot;oh62&quot;,
                      &quot;model&quot;: &quot;component_section_id&quot;
                  }
              ],
              &quot;format&quot;: &quot;column&quot;
          }
      ]
  }
}
</code></pre>

<p>And it will be passed:</p>

<pre><code class="sql">SELECT * 
FROM matrix AS oh1
WHERE (oh1.section_tipo='oh1') AND 
  (oh1.section_id = 1 OR oh1.section_id = 6)
ORDER BY oh1.section_id ASC 
LIMIT 10
</code></pre>

<p>2.- format &#8220;in_column&#8221; the same SQO:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;oh1&quot; ],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: [&quot;1,6&quot;],
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;oh1&quot;,
                      &quot;component_tipo&quot;: &quot;oh62&quot;,
                      &quot;model&quot;: &quot;component_section_id&quot;
                  }
              ],
              &quot;format&quot;: &quot;in_column&quot;
          }
      ]
  }
}
</code></pre>

<p>And it will be passed:</p>

<pre><code class="sql">SELECT *
FROM matrix AS oh1
WHERE (oh1.section_tipo='oh1') AND 
  (oh1.section_id IN(1,6))
ORDER BY oh1.section_id ASC
LIMIT 10
</code></pre>

<p>Both are valid SQL, but with different approach.</p>

<h5 id="use_function">use_function</h5>

<p>Defines the PostgreSQL function to be used in the query. The parameter is used in combination with <a href="#format">format</a> parameter with value <code>function</code>, <code>format</code> say to the SQO that it will use a function and <code>use_function</code> defines the name of the function to be used.
The function will be applied to WHERE statement enclosing the q and the main operator.</p>

<p>Definition: <code>string</code> if format is function use_function define the PostgreSQL function to be used. <strong>optional</strong>, ex: &#8216;relations_flat_fct_st_si&#8217;</p>

<p>Example: Search the types <a href="https://dedalo.dev/ontology/numisdata3">numisdata3</a> with the catalog <a href="https://dedalo.dev/ontology/numisdata309">numisdata309</a> value = 1.</p>

<p>Noramally this search will use a locator in this way:</p>

<pre><code class="json">{
    &quot;section_tipo&quot;: &quot;numisdata300&quot;,
    &quot;section_id&quot;: 1,
    &quot;from_component_tipo&quot;: &quot;numisdata309&quot;
}
</code></pre>

<p>But in SQL is hard to index all locators because it&#8217;s not static combination of properties, so, in theses cases is possible to use a flat version (string version of the locator) to speed up the search.</p>

<p>The previous locator to search can be flatten as: <code>numisdata309_numisdata300_1</code> And use it to search in the indexed function <code>relations_flat_fct_st_si</code> in this way:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;numisdata3&quot; ],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: &quot;\&quot;numisdata309_numisdata300_1\&quot;&quot;,
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;numisdata3&quot;,
                      &quot;component_tipo&quot;: &quot;numisdata309&quot;
                  }
              ],
              &quot;format&quot;: &quot;function&quot;,
              &quot;use_function&quot;: &quot;relations_flat_fct_st_si&quot;
          }
      ]
  }
}
</code></pre>

<p>It will be format as SQL:</p>

<pre><code class="sql">SELECT * 
FROM matrix AS nu3
WHERE (nu3.section_tipo='numisdata3') AND nu3.section_id&gt;0  AND (
relations_flat_fct_st_si(nu3.datos)@&gt; '[&quot;numisdata309_numisdata300_1&quot;]')
ORDER BY nu3.section_id ASC 
LIMIT 10
</code></pre>

<p>This search is around x100 times faster than the same search with the full locator.</p>

<h5 id="q_split">q_split</h5>

<p>Defines if the words or the query (in <a href="#q">q</a> parameter) need to be split into multiple WHERE statements. When q_split is set to true, it create multiple WHERE for every word in the query and add a AND operator between them because the words will be searched at any place of the text, be default it set in true.</p>

<p>Defintion : <code>bool</code> (true || false) defines if the q need to be split into multiple WHERE queries. Default : true <strong>optional</strong>, ex: &#8216;false&#8217;</p>

<p>Example: Search the interviews <a href="https://dedalo.dev/ontology/oh1">oh1</a> abstract <a href="https://dedalo.dev/ontology/oh23">oh23</a> has the words &#8220;war 1939&#8221;</p>

<p>Look the text:</p>

<p>&#8220;&#8230; the Spanish Civil War ended at April 1th of 1939 &#8230;&#8221;</p>

<p>With q_split set in true the search will find it.
With q_split set in false the search will not find it, because the words &#8220;war&#8221; and &#8220;1939&#8221; are not in the order to search, it has &#8220;ended at April 1th of&#8221; words in middle.</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;oh1&quot; ],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: &quot;war 1939&quot;,
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;oh1&quot;,
                      &quot;component_tipo&quot;: &quot;oh23&quot;
                  }
              ],
              &quot;q_split&quot;: true,
          }
      ]
  }
}
</code></pre>

<pre><code class="sql">SELECT *
FROM matrix AS oh1
WHERE (oh1.section_tipo='oh1') AND oh1.section_id&gt;0  AND ( (
  f_unaccent(oh1.datos#&gt;&gt;'{components,oh23,dato}') ~* f_unaccent('.*&quot;.*war.*') AND
  f_unaccent(oh1.datos#&gt;&gt;'{components,oh23,dato}') ~* f_unaccent('.*&quot;.*1939.*') 
))
ORDER BY oh1.section_id ASC
LIMIT 10
</code></pre>

<p>But when the q_split is set to false:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;oh1&quot; ],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: &quot;war 1939&quot;,
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;oh1&quot;,
                      &quot;component_tipo&quot;: &quot;oh23&quot;
                  }
              ],
              &quot;q_split&quot;: false,
          }
      ]
  }
}
</code></pre>

<p>The SQL where sentence will has only 1 statement with the sentence to be search as exactly the user has input and, in these case, it do not match.</p>

<pre><code class="sql">SELECT *
FROM matrix AS oh1
WHERE (oh1.section_tipo='oh1') AND oh1.section_id&gt;0  AND ( (
  f_unaccent(oh1.datos#&gt;&gt;'{components,oh23,dato}') ~* f_unaccent('.*&quot;.*war 1939.*')
))
ORDER BY oh1.section_id ASC
LIMIT 10
</code></pre>

<h5 id="unaccent">unaccent</h5>

<p>Defines if the unaccent function will be applied to the <a href="#q">q</a>. Unaccented function search without the accent and all letters will searched in lowercase (without match the case of the letter), by default text search set this parameter to true. THis function is ussed by languages as Spanish, Catalan or French that use accent letters suck as: àáäâéèëêìíïîòóöôùúüû etc.</p>

<p>Description: <code>bool</code> (true || false) defines if the q will us the unaccent function to remove accent characters in WHERE <strong>optional</strong>, ex: &#8216;false&#8217;</p>

<p>Example: Search interviews <a href="https://dedalo.dev/ontology/oh1">oh1</a> abstract <a href="https://dedalo.dev/ontology/oh23">oh23</a> has the word <code>Bèl·lic</code>, unaccent function will match any words as <code>bel·lic</code>, <code>Bel·lic</code>, <code>bèl·lic</code>, etc.</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;oh1&quot; ],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: &quot;Bèl·lic&quot;,
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;oh1&quot;,
                      &quot;component_tipo&quot;: &quot;oh23&quot;
                  }
              ],
              &quot;unaccent&quot;: true
          }
      ]
  }
}
</code></pre>

<p>It will be transform to SQL as:</p>

<pre><code class="sql">SELECT DISTINCT *
FROM matrix AS oh1
WHERE (oh1.section_tipo='oh1') AND oh1.section_id&gt;0  AND 
  (f_unaccent(oh1.datos#&gt;&gt;'{components,oh23,dato}') ~* f_unaccent('.*&quot;.*Bèl·lic.*') )
ORDER BY oh1.section_id ASC
LIMIT 10
</code></pre>

<p>But, if we want to search exactly the word as user typed, it&#8217;s possible to disable unaccent:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;oh1&quot; ],
  &quot;filter&quot;: {
      &quot;$and&quot;: [
          {
              &quot;q&quot;: &quot;Bélic&quot;,
              &quot;path&quot;: [
                  {
                      &quot;section_tipo&quot;: &quot;oh1&quot;,
                      &quot;component_tipo&quot;: &quot;oh23&quot;
                  }
              ],
              &quot;unaccent&quot;: false
          }
      ]
  }
}
</code></pre>

<p>The SQL where sentence will doesn&#8217;t have the unaccent function.</p>

<pre><code class="sql">SELECT DISTINCT *
FROM matrix AS oh1
WHERE (oh1.section_tipo='oh1') AND oh1.section_id&gt;0  AND 
  (oh1.datos#&gt;&gt;'{components,oh23,dato}' ~* '.*&quot;.*Bélic.*')
ORDER BY oh1.section_id ASC
LIMIT 10
</code></pre>

<h5 id="type">type</h5>

<p>Defines if the search will use json or string format into the WHERE SQL clause. In Dédalo all data is stored in JSON format, every component has his own data inside an array, but some components has a string as value and other has a object. If the component has object, such as component_date, the search will use the <code>json</code> type, but if the component has a string as value, as component_input_text, it will dicide if it will use the <code>jsonb</code> or <code>string</code> type dependent of the <a href="#q">q</a>.</p>

<p>Definition: <code>string</code> (&#8216;jsonb&#8217; || 'string) defines the type of data to be searched <strong>optional</strong>, ex: &#8216;jsonb&#8217;</p>

<p>Example: search interviews <a href="https://dedalo.dev/ontology/oh1">oh1</a> with title <a href="https://dedalo.dev/ontology/oh16">oh16</a> <code>mother</code> in jsonb format.</p>

<pre><code class="json">{
 &quot;section_tipo&quot;: [&quot;oh1&quot;],
    &quot;filter&quot;: {
        &quot;$and&quot;: [
            {
                &quot;q&quot;: [ &quot;mother&quot; ],
                &quot;path&quot;: [
                    {
                        &quot;section_tipo&quot;: &quot;oh1&quot;,
                        &quot;component_tipo&quot;: &quot;oh16&quot;
                    }
                ],
                &quot;type&quot;: &quot;jsonb&quot;
            }
        ]
    }
}
</code></pre>

<h3 id="limit">limit</h3>

<p>Defines the maximum records to get from the database. It is equivalent to LIMIT in SQL.</p>

<p>Definition: <code>int</code> records limit <strong>optional</strong>, ex: 10</p>

<p>Example: search the first 10 interviews <a href="https://dedalo.dev/ontology/oh1">oh1</a> with title <a href="https://dedalo.dev/ontology/oh16">oh16</a> <code>mother</code>.</p>

<pre><code class="json">{
 &quot;section_tipo&quot;: [&quot;oh1&quot;],
    &quot;filter&quot;: {
        &quot;$and&quot;: [
            {
                &quot;q&quot;: [ &quot;mother&quot; ],
                &quot;path&quot;: [
                    {
                        &quot;section_tipo&quot;: &quot;oh1&quot;,
                        &quot;component_tipo&quot;: &quot;oh16&quot;
                    }
                ]
            }
        ]
    },
    &quot;limit&quot;: 10
}
</code></pre>

<h3 id="offset">offset</h3>

<p>Defines the amount or distance is out of records to get records from the database. It is equivalent to OFFSET in SQL.
<code>offset</code> says how many records to skip before beginning to return records. <code>offset</code> 0 is the same as omitting it or with null value. It is used in combination with limit to paginate / navigate between records.</p>

<p>Definition: <code>int</code> records to skip <strong>optional</strong>, ex: 10</p>

<p>Example: search the next 10 interviews <a href="https://dedalo.dev/ontology/oh1">oh1</a> with title <a href="https://dedalo.dev/ontology/oh16">oh16</a> <code>mother</code> after the first 10 interviews that match the criteria (it will return the 11 to 20 interviews)</p>

<pre><code class="json">{
 &quot;section_tipo&quot;: [&quot;oh1&quot;],
    &quot;filter&quot;: {
        &quot;$and&quot;: [
            {
                &quot;q&quot;: [ &quot;mother&quot; ],
                &quot;path&quot;: [
                    {
                        &quot;section_tipo&quot;: &quot;oh1&quot;,
                        &quot;component_tipo&quot;: &quot;oh16&quot;
                    }
                ]
            }
        ]
    },
    &quot;limit&quot;: 10,
    &quot;offset&quot; : 10
}
</code></pre>

<h3 id="full_count">full_count</h3>

<p>Defines if the search will count the total records found. When full_count is enable, SQO will create 2 different SQL, first one with the search and second one to count the records, both SQL will be processed in parallel. This parameter is used to get the total records found, as this SQL could take lot of time and server resources, normally only is active in the first query, the following requests set this parameter with the total perviously calculated, this action remove the execution of get the total at every requests.</p>

<p>Definition: <code>bool || int</code> (true || false || 1) get the total records find . When int is passed disable the function for full count and get the number as total <strong>optional</strong>, ex: true</p>

<p>Example: search the first 10 interviews <a href="https://dedalo.dev/ontology/oh1">oh1</a> with title <a href="https://dedalo.dev/ontology/oh16">oh16</a> <code>mother</code> and count the total matches.</p>

<pre><code class="json">{
 &quot;section_tipo&quot;: [&quot;oh1&quot;],
    &quot;filter&quot;: {
        &quot;$and&quot;: [
            {
                &quot;q&quot;: [ &quot;mother&quot; ],
                &quot;path&quot;: [
                    {
                        &quot;section_tipo&quot;: &quot;oh1&quot;,
                        &quot;component_tipo&quot;: &quot;oh16&quot;
                    }
                ]
            }
        ]
    },
    &quot;limit&quot;: 10,
    &quot;full_count&quot;: true
}
</code></pre>

<pre><code class="sql">--1 search the records:
SELECT *
FROM matrix AS oh1
WHERE (oh1.section_tipo='oh1') AND oh1.section_id&gt;0  AND 
  (f_unaccent(oh1.datos#&gt;&gt;'{components,oh16,dato}') ~* f_unaccent('.*\[&quot;.*mother.*'))
ORDER BY oh1.section_id ASC 
LIMIT 10;

-- 2 count the total
SELECT COUNT(*) as full_count FROM (
  SELECT DISTINCT oh1.section_id
  FROM matrix AS oh1
  WHERE (oh1.section_tipo='oh1') AND oh1.section_id&gt;0  AND 
    (f_unaccent(oh1.datos#&gt;&gt;'{components,oh16,dato}') ~* f_unaccent('.*\[&quot;.*mother.*'))
)
x;
</code></pre>

<h3 id="order">order</h3>

<p>Defines the component or components that will use to order the records found. Order is set as array of columns that defines the configuration of the component to be used to configure the order, every object has a <a href="#path-1">path</a> and <a href="#direction">direction</a>, the array order fix the priority.</p>

<p>Definition: <code>array of objects</code> set the order of the records, every object in the array will be a column with his paths and direction <strong>optional</strong> <code>[{&quot;direction&quot;: &quot;ASC&quot;, &quot;path&quot;:[{ddo},{ddo}]}]]</code></p>

<p>Example: give me the first 10 records of Numismatic objects <a href="https://dedalo.dev/ontology/numisdata4">numisdata4</a> orderer by Collections <a href="https://dedalo.dev/ontology/numisdata159">numisdata159</a> people name <a href="https://dedalo.dev/ontology/rsc85">rsc85</a> in descendent order.</p>

<pre><code class="json">{
    &quot;section_tipo&quot;: [ &quot;numisdata4&quot; ],
    &quot;limit&quot;: 10,
    &quot;offset&quot;: 0,
    &quot;order&quot;: [
        {
            &quot;direction&quot;: &quot;DESC&quot;,
            &quot;path&quot;: [
                 {
                    &quot;component_tipo&quot;: &quot;numisdata159&quot;,
                    &quot;model&quot;: &quot;component_portal&quot;,
                    &quot;section_tipo&quot;: &quot;numisdata4&quot;
                },
                {
                    &quot;component_tipo&quot;: &quot;rsc85&quot;,
                    &quot;model&quot;: &quot;component_input_text&quot;,
                    &quot;section_tipo&quot;: &quot;rsc194&quot;
                }
            ]
        }
    ]
}
</code></pre>

<p>It will be processed as SQL:</p>

<pre><code class="sql">SELECT *
FROM (
  SELECT DISTINCT ON (nu4.section_id) nu4.section_id,
  nu4.section_tipo,
  nu4.datos,
  nu4_nu159_rs194.datos#&gt;&gt;'{components,rsc85,dato,lg-nolan}' as rsc85_order
  FROM matrix AS nu4
  -- join Numisamtic object with the relations with Collections section
  LEFT JOIN relations AS r_nu4_nu159_rs194 ON (nu4.section_id=r_nu4_nu159_rs194.section_id AND nu4.section_tipo=r_nu4_nu159_rs194.section_tipo AND r_nu4_nu159_rs194.from_component_tipo='numisdata159')
  LEFT JOIN matrix AS nu4_nu159_rs194 ON (r_nu4_nu159_rs194.target_section_id=nu4_nu159_rs194.section_id AND r_nu4_nu159_rs194.target_section_tipo=nu4_nu159_rs194.section_tipo)
  WHERE (nu4.section_tipo='numisdata4') AND nu4.section_id&gt;0
  ORDER BY nu4.section_id ASC
) main_select
ORDER BY rsc85_order DESC NULLS LAST , section_id ASC
LIMIT 10;
</code></pre>

<h4 id="direction">direction</h4>

<p>Defines the order of the records. Used in combination with <a href="#order">order</a>.</p>

<p>Definition: <code>string</code> (ASC || DESC) sort direction of the column <strong>optional</strong>, ex: &#8216;DESC&#8217;</p>

<p>Example: give me the first 10 records of Numismatic objects <a href="https://dedalo.dev/ontology/numisdata4">numisdata4</a> orderer by Collections <a href="https://dedalo.dev/ontology/numisdata159">numisdata159</a> people name <a href="https://dedalo.dev/ontology/rsc85">rsc85</a> in ascendent order.</p>

<pre><code class="json">{
    &quot;section_tipo&quot;: [ &quot;numisdata4&quot; ],
    &quot;limit&quot;: 10,
    &quot;offset&quot;: 0,
    &quot;order&quot;: [
        {
            &quot;direction&quot;: &quot;ASC&quot;,
            &quot;path&quot;: [
                 {
                    &quot;component_tipo&quot;: &quot;numisdata159&quot;,
                    &quot;model&quot;: &quot;component_portal&quot;,
                    &quot;section_tipo&quot;: &quot;numisdata4&quot;
                },
                {
                    &quot;component_tipo&quot;: &quot;rsc85&quot;,
                    &quot;model&quot;: &quot;component_input_text&quot;,
                    &quot;section_tipo&quot;: &quot;rsc194&quot;
                }
            ]
        }
    ]
}
</code></pre>

<p>It will be processed as SQL:</p>

<pre><code class="sql">SELECT * 
FROM (
  SELECT DISTINCT ON (nu4.section_id) nu4.section_id,
  nu4.section_tipo,
  nu4.datos,
  nu4_nu159_rs194.datos#&gt;&gt;'{components,rsc85,dato,lg-nolan}' as rsc85_order
  FROM matrix AS nu4
 -- join Numisamtic object with the relations with Collections section
  LEFT JOIN relations AS r_nu4_nu159_rs194 ON (nu4.section_id=r_nu4_nu159_rs194.section_id AND nu4.section_tipo=r_nu4_nu159_rs194.section_tipo AND r_nu4_nu159_rs194.from_component_tipo='numisdata159')
  LEFT JOIN matrix AS nu4_nu159_rs194 ON (r_nu4_nu159_rs194.target_section_id=nu4_nu159_rs194.section_id AND r_nu4_nu159_rs194.target_section_tipo=nu4_nu159_rs194.section_tipo)
  WHERE (nu4.section_tipo='numisdata4') AND nu4.section_id&gt;0
  ORDER BY nu4.section_id ASC
) main_select
ORDER BY rsc85_order ASC NULLS LAST , section_id ASC
LIMIT 10;
</code></pre>

<h4 id="path">path</h4>

<p>Defines the path to follow to get the component to be used in the order.</p>

<p>Sections are connected by locators, and is necessary follow the path to locate the component in the target section. For example, Numismatic object section <a href="https://dedalo.dev/ontology/numisdata4">numisdata4</a> has a component named Collection <a href="https://dedalo.dev/ontology/numisdata159">numisdata159</a> that point to People section <a href="https://dedalo.dev/ontology/rsc194">rsc194</a>. If we want to order by the name of the collection person, is necessary to locate the component Name <a href="https://dedalo.dev/ontology/rsc85">rsc85</a> in the Person section. To do that, path defines the components to be followed until the target.</p>

<pre><code class="mermaid">    graph LR
    A((&quot;Numismatic objects :: section&quot;))--&gt;B(Collections :: component_portal)
    B--&gt;C((&quot;People :: section&quot;))
    C--&gt;D(&quot;Name :: component_input_text&quot;)
</code></pre>

<p>To define the component is used the <a href="dd_object.md">ddo</a> definition. The previous graph will be represented as:</p>

<pre><code class="json">[
  {
    &quot;component_tipo&quot;: &quot;numisdata159&quot;,
    &quot;model&quot;: &quot;component_portal&quot;,
    &quot;section_tipo&quot;: &quot;numisdata4&quot;
  },
  {
    &quot;component_tipo&quot;: &quot;rsc85&quot;,
    &quot;model&quot;: &quot;component_input_text&quot;,
    &quot;section_tipo&quot;: &quot;rsc194&quot;
  }
]
</code></pre>

<p>The last ddo in the array is the target component to use in the order.</p>

<p>Definition: <code>array of objects</code> the <a href="dd_object.md">ddo</a> object that defines the path of the column beginning from the main section of the filter and path of ddo to the component in related section/s. <strong>optional</strong> <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;,&quot;component_tipo&quot;:&quot;oh24&quot;},{&quot;section_tipo&quot;:&quot;rsc197&quot;, &quot;component_tipo&quot;:&quot;rsc85&quot;}]</code></p>

<p>Example: give me the first 10 records of Numismatic objects <a href="https://dedalo.dev/ontology/numisdata4">numisdata4</a> orderer by Collections <a href="https://dedalo.dev/ontology/numisdata159">numisdata159</a> people name <a href="https://dedalo.dev/ontology/rsc85">rsc85</a> in ascendent order.</p>

<pre><code class="json">{
    &quot;section_tipo&quot;: [ &quot;numisdata4&quot; ],
    &quot;limit&quot;: 10,
    &quot;offset&quot;: 0,
    &quot;order&quot;: [
        {
            &quot;direction&quot;: &quot;ASC&quot;,
            &quot;path&quot;: [
                 {
                    &quot;component_tipo&quot;: &quot;numisdata159&quot;,
                    &quot;model&quot;: &quot;component_portal&quot;,
                    &quot;section_tipo&quot;: &quot;numisdata4&quot;
                },
                {
                    &quot;component_tipo&quot;: &quot;rsc85&quot;,
                    &quot;model&quot;: &quot;component_input_text&quot;,
                    &quot;section_tipo&quot;: &quot;rsc194&quot;
                }
            ]
        }
    ]
}
</code></pre>

<p>It will be processed as SQL:</p>

<pre><code class="sql">SELECT * 
FROM (
  SELECT DISTINCT ON (nu4.section_id) nu4.section_id,
  nu4.section_tipo,
  nu4.datos,
  nu4_nu159_rs194.datos#&gt;&gt;'{components,rsc85,dato,lg-nolan}' as rsc85_order
  FROM matrix AS nu4
 -- join Numisamtic object with the relations with Collections section
  LEFT JOIN relations AS r_nu4_nu159_rs194 ON (nu4.section_id=r_nu4_nu159_rs194.section_id AND nu4.section_tipo=r_nu4_nu159_rs194.section_tipo AND r_nu4_nu159_rs194.from_component_tipo='numisdata159')
  LEFT JOIN matrix AS nu4_nu159_rs194 ON (r_nu4_nu159_rs194.target_section_id=nu4_nu159_rs194.section_id AND r_nu4_nu159_rs194.target_section_tipo=nu4_nu159_rs194.section_tipo)
  WHERE (nu4.section_tipo='numisdata4') AND nu4.section_id&gt;0
  ORDER BY nu4.section_id ASC
) main_select
ORDER BY rsc85_order ASC NULLS LAST , section_id ASC
LIMIT 10;
</code></pre>

<h3 id="order_custom">order_custom</h3>

<p>Defines a specific order of the search. Sometimes is necessary order the query result in specific way, instead alphabetic order or numeric order used by the default <a href="#order">order</a>, order_custom could order by any other criteria. For example: order a list by the creation time.</p>

<p>Definition: <code>array of objects</code> order by specific values <strong>optional</strong>, ex: <code>[{&quot;section_tipo&quot;: section_tipo, &quot;column_name&quot;: column_name, &quot;column_values&quot;: [values]}}</code></p>

<p>Example: give the list of Numismatic object section <a href="https://dedalo.dev/ontology/numisdata4">numisdata4</a> with odd section_id in descending order (5,3,1).</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;numisdata4&quot;],
  &quot;order_custom&quot;: [{
    &quot;section_tipo&quot;:&quot;numisdata4&quot;,
    &quot;column_name&quot;: &quot;section_id&quot;,
    &quot;column_values&quot;: [5,3,1] 
  }]
}
</code></pre>

<p>The equivalent SQL:</p>

<pre><code class="sql">SELECT * 
FROM (
  SELECT DISTINCT ON (nu4.section_id) nu4.section_id,
  nu4.section_tipo,
  nu4.datos
  FROM matrix AS nu4
  WHERE (nu4.section_tipo='numisdata4') AND nu4.section_id&gt;0 
  ORDER BY nu4.section_id ASC
) main_select
LEFT JOIN (VALUES ('numisdata4',5,1),('numisdata4',3,2),('numisdata4',1,3)) as x(ordering_section_tipo, ordering_id, ordering) ON main_select.section_id=x.ordering_id AND main_select.section_tipo=x.ordering_section_tipo 
ORDER BY x.ordering ASC
LIMIT 10
</code></pre>

<h4 id="section_tipo">section_tipo</h4>

<p>Defines the section tipo of the colum that will used in the order_custom.</p>

<p>Definition: <code>string</code> name of section to be used to be ordered <strong>optional</strong></p>

<h4 id="column_name">column_name</h4>

<p>Defines the name of the column to be ordered. The column name has to be defined the ontology inside the section_tipo.</p>

<p>Definition: <code>string</code> name of the column to be ordered <strong>optional</strong></p>

<h4 id="column_values">column_values</h4>

<p>Defines the values to be used in the custom order.</p>

<p>Definition: <code>array</code> the array defines the order of the values <strong>optional</strong></p>

<h3 id="filter_by_locators">filter_by_locators</h3>

<p>Define a array with fixed <a href="locator.md">locators</a> to be applied to the search. filter_by_locators is used when a query has a fixed data to be applied at any query, it is independent of the filter <a href="#q">q</a> values and used to get a set of records previously than will be filtered by the q criteria. filter_by_locators has preference to other criteria define in filter.</p>

<p>Definition: <code>array of objects</code> set a order by locators, every object is a <a href="locator.md">locator</a> and the order of the array will be respected <strong>optional</strong> ex : <code>[{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;section_id&quot;:&quot;8&quot;},{&quot;section_tipo&quot;:&quot;oh1&quot;, &quot;section_id&quot;:&quot;3&quot;}]</code></p>

<p>Example: give me the section Types <a href="https://dedalo.dev/ontology/numisdata3">numisdata3</a> that use the image <a href="https://dedalo.dev/ontology/rsc170">rsc170</a> with section_id 69</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [&quot;numisdata3&quot;],
  &quot;mode&quot;: &quot;related&quot;,
  &quot;filter_by_locators&quot;: [
    {
      &quot;section_tipo&quot;: &quot;rsc170&quot;,
      &quot;section_id&quot;: &quot;69&quot;
    }
  ]
}
</code></pre>

<p>The SQL equivalent:</p>

<pre><code class="sql">SELECT section_tipo, section_id, datos
FROM &quot;matrix&quot;
WHERE (relations_flat_st_si(datos) @&gt; '[&quot;rsc170_69&quot;]'::jsonb)
  AND (section_tipo = 'numisdata3')
UNION ALL
SELECT section_tipo, section_id, datos
FROM &quot;matrix_activities&quot;
WHERE (relations_flat_st_si(datos) @&gt; '[&quot;rsc170_69&quot;]'::jsonb)
  AND (section_tipo = 'numisdata3')
UNION ALL
SELECT section_tipo, section_id, datos
FROM &quot;matrix_hierarchy&quot;
WHERE (relations_flat_st_si(datos) @&gt; '[&quot;rsc170_69&quot;]'::jsonb)
  AND (section_tipo = 'numisdata3')
UNION ALL
SELECT section_tipo, section_id, datos
FROM &quot;matrix_list&quot;
WHERE (relations_flat_st_si(datos) @&gt; '[&quot;rsc170_69&quot;]'::jsonb)
  AND (section_tipo = 'numisdata3')
ORDER BY section_tipo, section_id ASC
LIMIT 10
OFFSET 0;
</code></pre>

<h3 id="allow_sub_select_by_id">allow_sub_select_by_id</h3>

<p>Defines if the query will use a sub select in SQL to get a pre-selection of the query with section_id as selector. Used to improve the search speed, the filter will be applied into the sub select WHERE statement and the section_ids of the selection will be used to get the main section in the main SQL. By default is set to true.</p>

<p>Definition : <code>bool</code> (true || false) create a sub select in the SQL query to select pass the filter and get the id to select the main section default : true <strong>optional</strong> .</p>

<p>Example: give me the first 5 sections of Numismatic object section <a href="https://dedalo.dev/ontology/numisdata4">numisdata4</a> without preselecting sub select:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;numisdata4&quot;],
  &quot;allow_sub_select_by_id&quot;:false,
  &quot;limit&quot;: 5
}
</code></pre>

<p>The SQL equivalent:</p>

<pre><code class="sql">SELECT DISTINCT ON (nu4.section_id) nu4.section_id,
nu4.section_tipo,
nu4.datos
FROM matrix AS nu4
WHERE (nu4.section_tipo='numisdata4') AND nu4.section_id&gt;0
ORDER BY nu4.section_id ASC
LIMIT 5;
</code></pre>

<p>the same with preselecting sub select</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;numisdata4&quot;],
  &quot;allow_sub_select_by_id&quot;:true,
  &quot;limit&quot;: 5
}
</code></pre>

<p>The SQL equivalent:</p>

<pre><code class="sql">SELECT DISTINCT ON (nu4.section_id) nu4.section_id,
nu4.section_tipo,
nu4.datos
FROM matrix AS nu4
WHERE nu4.id in (
  SELECT DISTINCT ON(nu4.section_id,nu4.section_tipo) nu4.id 
  FROM matrix AS nu4
  WHERE (nu4.section_tipo='numisdata4') AND nu4.section_id&gt;0
  ORDER BY nu4.section_id ASC
  LIMIT 5
)
ORDER BY nu4.section_id ASC
LIMIT 5;
</code></pre>

<h3 id="remove_distinct">remove_distinct</h3>

<p>Defines if the query will return unique records. If the SQL has a sub select is possible that multiple records will be returned, this parameter prevent this result. By default is deactivate.</p>

<p>Definition: <code>bool</code> (true || false) remove duplicates records when the SQL query has a sub select with multiple criteria that can get duplicate records. Default : false <strong>optional</strong></p>

<p>Example: give me the first 5 sections of Numismatic object section <a href="https://dedalo.dev/ontology/numisdata4">numisdata4</a> without preselecting sub select and without DISTINCT:</p>

<pre><code class="json">{
  &quot;section_tipo&quot;: [ &quot;numisdata4&quot;],
  &quot;allow_sub_select_by_id&quot;: false,
  &quot;remove_distinct&quot;: true,
  &quot;limit&quot;: 5
}
</code></pre>

<p>The SQL equivalent:</p>

<pre><code class="sql">SELECT nu4.section_id,
nu4.section_tipo,
nu4.datos
FROM matrix AS nu4
WHERE (nu4.section_tipo='numisdata4') AND nu4.section_id&gt;0
ORDER BY nu4.section_id ASC -- allow_sub_select_by_id=false
LIMIT 5;
</code></pre>

<h3 id="skip_projects_filter">skip_projects_filter</h3>

<p>Remove the projects filter applied to users. Every search inside Dédalo use the component_filter to restrict the section records that the user can get of any section. Every user has his own permissions to get one, two or more projects, projects are defined in section <a href="https://dedalo.dev/ontology/dd153">dd153</a> and is assign to every user in the system. Only general-admin and the root user remove the projects restriction using this property. By default is false and is not possible to change in the fly.</p>

<p>Definition: <code>bool</code> (true || false) remove the mandatory filter of the component_filter applied at all users except root and global admin users. Default : false <strong>optional</strong></p>

<h3 id="parsed">parsed</h3>

<p>Defines if the SQO has been parsed by the components and has his own operators.</p>

<p>Definition: <code>bool</code> (true || false) state of the sqo, it indicates if the filter was parsed by the components to add operators to the q. It&#8217;s used as internal property, but is possible parse it manually and indicate this state. Default false <strong>optional</strong></p>

</body>
</html>

